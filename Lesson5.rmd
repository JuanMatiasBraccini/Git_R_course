---
title: "Lesson 5. Data manipulation and looping"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "C:/Matias/Cursos/2019_Mexico/htmls") })

output: 
  html_document:
    code_folding: show
    highlight: haddock
    keep_md: yes
    theme: united
---

<style type="text/css">
h1.title {
  font-size: 30px;
    color: Maroon;
  text-align: center;
          }
h3.subtitle {
  font-size: 22px;
    color: Maroon;
  text-align: center;
            }
h4.author { 
    font-size: 24px;
      color: FireBrick;
  text-align: center;
          }
h4.date { 
  font-size: 18px;
  text-align: center;
        }
h1{
  font-size: 22px;
  color: DarkBlue;
  }
h2{
  font-size: 20px;
  color: Blue;
  }
h3{
  font-size: 18px;
  color: SteelBlue;
  }
body{
    font-family: Helvetica;
    font-size: 14pt;
    }
code.r{
  font-size: 16pt;
      }
pre {
  font-size: 16pt;
}
</style>


```{r globaloptions, include=FALSE}
knitr::opts_chunk$set(fig.width = 6,fig.height = 6,error=TRUE,
                        echo = TRUE, warning=FALSE,message=FALSE)
```

# Lesson goals
We're going to manipulate data, i.e. clean it, reshape it, aggregate it, use loops, etc.

<br>
Credits to John Hoenig, Ainslie Denham and Alex Hesp
<br><br>


## Data manipulation
By this I mean  anything that needs to be done to a data set in order to perform a given
analysis....

```{r}
# Let's start with a clean slate
rm(list=ls())

# Let's read in some age and length data from a .csv file 
#   and have a quick look at it
options(stringsAsFactors = FALSE)
LenAgeDat <- read.csv(
  "C:/Matias/Cursos/2019_Mexico/Data.sets/Lesson5_LenAtAgeData.csv",
  header = T)
head(LenAgeDat,2)
tail(LenAgeDat,2)

#other basic options for reading in data
#read.table()
#read.delim()
#readWorksheetFromFile() from the XLConnect package
#read_excel() from the readxl package


# what variables/fields do we have?
names(LenAgeDat)

# What areas are there in the data set? 
unique(LenAgeDat$Area)

# what sexes are there?
unique(LenAgeDat$SexNameVec)
# note: Levels in result indicates the structure type
# (text)is stored as a factor ie. Female=1 , Male =2.
# Defaults by alphabetical order

# and there is a corresponding numeric code for sex
unique(LenAgeDat$SexNumVec)
# ...seems reasonable, its not like there are 3 or 1, 
# when we know there should be 2 (females and males)


# Let's get a bit of information regarding the age data
summary(LenAgeDat$ObsAge)
# OK, a fairly short-lived fish, with maximum age of 10, 
#    with some fish caught at one.


# Let's store the min and max age
(MinAge <- min(LenAgeDat$ObsAge))
(MaxAge <- max(LenAgeDat$ObsAge))
# remember, if we put brackets around the thing, 
#  then it will print out to the console

# we can also get the range this way
AgeRange <- range(LenAgeDat$ObsAge)

# so we could also store the minimum and maximum ages 
#   as variables this way, if we wanted to
(MinAge <- AgeRange[1])
(MaxAge <- AgeRange[2])


# Let's make a vector containing our age categories,  
#  which we can use later
(AgeClasses <- seq(MinAge,MaxAge,1))

# What about length? Let's learn a bit more
summary(LenAgeDat$ObsLen)
# fish gets up to 346

# So, what would be the age composition fish for females in area 1?
# We can subset the data for female fish in area 1
SubDat <- LenAgeDat[LenAgeDat$Area==1,]
head(SubDat)
# so in LenAgeDat[LenAgeDat$Area==1,], we are saying, in the
#  data frame called 'LenAgeDat', take the rows for which the 
#  area column has a value of 1 (it is the row column because its
#  left of the comma in the square brackets). 
# In other words, think of [row,column] when you're subsetting 
#  using square brackets. 
# Because we've put nothing after the comma in the brackets, 
#  we are saying keep all the columns in the original data frame,
#  but subset for specific rows.
# Then we assign this (i.e. by using <-) to the new object 
#  called 'SubDat',

SubDat1 <- subset(LenAgeDat,Area==1)  #same result...
head(SubDat1==SubDat)


#  VIP: By using a different variable name, i.e. Subdata, rather
# than LenAgeDat, we keep the original data unchanged in memory


# how much data have we got. Looking at the environment window 
#  (topright),it says there are 157 observations for SubDat. 

# Let's check it another way
(length(SubDat$ObsAge))
(length(SubDat$ObsLen))
# so there are 157 age observations, 
# 157 length observations and so on. 
# If there were different numbers of ages and lengths, 
#  that could mean a problem, but OK here


# Another way is to check the dataframe "dimensions"
dim(SubDat)
# so the data frame has 157 rows and 5 columns


# Now, let's subset the data further, for females
SubDat <- SubDat[SubDat$SexNameVec=="Female",]
# Here, because I've used the name SubDat on both the left 
#  and right of the assingment sign (<-), we overwrite 
#  the original subsetted data (containing all data for 
#  area 1) with a data frame containing only females in area 1 

# how many observations now? Environment window says its 
#  gone down to 75.
dim(SubDat)


# We could end up with the same result produced by the 
#  above two lines of code using this single line of code, 
#  by subsetting our original data frame to contain data 
#  for only females in area 1 in a single go,
SubDat <- LenAgeDat[LenAgeDat$Area==1 & 
                      LenAgeDat$SexNameVec=="Female",]
# So here, we've asked to retain only the rows of data for 
#  which area = 1 and sex = Females. 

# Either way is fine.


# Let's look at the age and length composition data for 
# females in area 1...How many fish do we have for each age?
table(SubDat$ObsAge)

# Let's use the frequency function to plot it
AgeCats <- c(0,AgeClasses)


#before plotting...
# There is a plotting function, which specifies information
#   regarding number of plots on a page, and how they are 
#   positioned, and how much space around each plot. 
# Here, we are saying 2 plots per page
#?par
par(mfcol=c(2,1),mar=c(4,4,2,2))

#now plot the histogram
HistData=hist(SubDat$ObsAge, breaks=AgeClasses, right=FALSE,
              col="pink", main="", xlab="Age class", 
              ylab="Frequency",las=1,xlim=c(0,10))

# if we want, we can look at the ages and corresponding 
#  frequencies this way
HistData$breaks # ages
HistData$counts
# frequencies at corresponding ages (same result as from
#  table function above)


# OK, great, what about males in area 1. Let's subset again
SubDat <- LenAgeDat[LenAgeDat$Area==1 & 
                      LenAgeDat$SexNameVec=="Male",]
HistData=hist(SubDat$ObsAge, breaks=AgeClasses, right=FALSE,
              col="light blue", main="", xlab="Age class",
              ylab="Frequency",las=1,xlim=c(0,10))

#...but we seem to be repeating the same code over and over
#    again - too tedious and prone to errors.... 
#   Imagine we had 10 or 20 plots to do.... has to be a better way


# ...the alternative...use loops...

# Let's say we want to do something 5 times, e.g. start at zero and
#  add one to the number 5 times (answer should be 5, right?)

# without a loop first. 
i = 0  #Let's call the variable for our number "i"
(i = i + 1) # add one
(i = i + 1) #again
(i = i + 1) #again
(i = i + 1) #again
(i = i + 1) # one last time

#loop version
i <- 0
for (j in 1:5)
{
  i <- i + 1
}
i

i <- 0 
for (j in 1:5) i<-i+1 #same.. (don't need {} if only 1 line of code)
i

#see what the loop is doing
i <- 0
for (j in 1:5)
{
  i <- i + 1
  print(i)
}

# so, let's say we wanted to loop backwards from 5 to 1
i = 0
for (j in seq(from=5,to=1,by=-1)) {
  i = i + 1
}
i
# we get 5? Why? Well, even though we are going backwards,
#  the thing we are doing, adding 1 to i each time, is 
#  still happening 5 times
# Did we really go backwards and end up at 1? What's the 
#  value of our loop counter variable?
j
# yes, after looped, it's now at 1!


# So what's happening in the loop?
i = 0
for (j in seq(from=5,to=1,by=-1)) {
  cat("in loop number",j,"before adding one, i = ",i,"\n")
    i = i + 1
  cat("in loop number",j,"after adding one, i = ",i,"\n")
}
i
# ?cat
# ...useful for understanding what is going on when looping,
# and finding errors - or "debugging"


# say we wanted to go forwards to 1000, in increments of 2
i = 0
N=1e7
system.time({for (j in seq(from=1,to=N,by=1)) {
  i = i + 1
}})
i

#faster way
system.time(length(seq(from=1,to=N,by=1)))

#...don't always want to use loops....

```

## Student task 1
Try plotting a histogram of 'ObsAge' for females in area 1 and then area 2 using a loop\

Use par() to show the two histograms in one page 

<br>

## Let's combine loops and functions to reduce number of code lines

```{r}
#let's plot females and males by area in one single page

  #first, create a function for plotting the histogram
fn.hist=function(d,CL,Area)
{
  hist(d$ObsAge,breaks=AgeClasses, right=FALSE,col=CL, 
         main=paste("area=",Area,"sex=",Sex.vec[s]),
         xlab="Age class",ylab="Frequency",las=1,xlim=c(0,10))
}
  #next, create useful vectors
Sex.vec=c("Female","Male")
CL.sex=c("pink","light blue")

  #finally, apply double loop
par(mfcol=c(2,2),mar=c(4,4,2,2))
for(s in 1:length(Sex.vec))
{
  for(a in 1:length(area.vec))
  {
    fn.hist(d=subset(LenAgeDat,SexNameVec==Sex.vec[s] & Area==a),
            CL=CL.sex[s],
            Area=a)
  } #end of area loop
} #end of sex loop

# It's good coding practice when using multiple loops to indent code,
#  line up the brackets and write a comment at the end of each 
#  closing bracket to identify which loop it belongs to 

```

<br>

## Student task 2
Repeat for 'ObsLen' (i.e. show histogram form each sex and area in 1 page) 
(tip, think about the break classes and xlim used in the histogram)

<br><br>

## Enter package dplyr

```{r}
library(dplyr)  #load this library, we will use it shortly..


# SECTION 1: Read in data
# In order to do some data management, we need to have some  
#   actual data that we can manage, so lets import some data to use.

# First, have a look at what's in the current 
dir()
list.files()

hndl="C:/Matias/Cursos/2019_Mexico/Data.sets/"
dat=read.csv(paste(hndl,
              "Lesson5_fisheries catch and effort data.csv",sep=""))

# This data set is completely made up. It is meant to be a very
#  simple example of a fisheries catch and effort data set with each 
#  row representing a unique fishing event by a vessel in a given 
#  year and month.

#useful functions when first looking at your data
dim(dat)
str(dat)
summary(dat)

# As this data set is rather small (15 observations),
#  lets look at the whole data set
dat
# Note that I have purposefully made some errors in the data set 
#  to make it a little more real, and so that we can see how 
#  to deal with some of these errors.

#there are some missing values...
unique(dat$vessel)

# let's say these are data entry errors so we want
# to rectify them in the code
#(note: in an ideal world, we'd report it back to the data team
#    so they can change it in the database)

#say we know the missing vessel for the 27th of January 2014
#  is "A001"
dat$vessel[dat$year==2014 & dat$month=="Jan" & dat$days==27]
dat$vessel[dat$year==2014 & dat$month=="Jan" & dat$days==27]="A001"
dat$vessel[dat$year==2014 & dat$month=="Jan" & dat$days==27]

#or say we know all missing vessl records are from "A001"
dat$vessel=ifelse(dat$vessel=="","A001",dat$vessel)
unique(dat$vessel)

#alternative, we can use with() to minimize coding
dat$vessel=with(dat,ifelse(vessel=="","A001",vessel))

#missing numeric values (shown as NA)
unique(dat$numcrew)
unique(dat$catch)

dat$catch=with(dat,ifelse(is.na(catch),mean(catch,na.rm=T),catch))
dat$numcrew=with(dat,ifelse(is.na(numcrew),round(mean(numcrew,na.rm=T)),numcrew))

unique(dat$numcrew)
unique(dat$catch)
```

<br>

## Basic data manipulation
* 1 Add new variables (e.g. calculate catch rate = catch/effort)
* 2 Select/remove columns (variables)
* 3 Select/remove rows (observations)
* 4 Change the ordering of the observations

```{r}
# 1 Add new variables
  #using base package (what we've been doing so far)
dat$cpue1 = dat$catch/dat$days
head(dat,2)

  #using dplyr (better coding practice...)
dat=mutate(dat, cpue2 = catch/days)

dat$cpue1
dat$cpue2

  #using piping and dplyr (much better codding practice)
dat1=dat%>%mutate(cpue=catch/days)

```
## PIPING  uses the pipe operator which looks like this  '%>%'
* The dplyr package imports this operator from another package (magrittr). 
* This operator allows you to pipe the output from one function to the input of another
function.
* Instead of nesting functions (reading from the inside to the outside), the
idea of of piping is to read the functions from left to right


basic tutorial on how to use pipes
https://www.datacamp.com/community/tutorials/pipe-r-tutorial#howto


```{r}
# 2 Select/remove columns (variables)

# Some ways to SELECT one or more columns
#   base packages approach
subdat1 = dat[, c("year", "month", "cpue1")]
head(subdat1,2)
    # or 
subdat1 = dat[, c(1,2,8)]
head(subdat1,2)
    # or
subdat1 = data.frame(year=dat$year, month=dat$month, cpue1=dat$cpue1)
head(subdat1,2)
    #or
subdat1 = subset(dat, select=c(year, month, cpue1))
head(subdat1,2)

#  dplyr
subdat1=dat%>%select(year, month, cpue1)
head(subdat1,2)


# Some ways to REMOVE one or more columns
#First let's save our data set to a new name so we don't delete all 
# our data, i.e. let's just make a copy of our data
newdat=dat
head(newdat,2)

# To remove a single column, we can set the column equal to NULL
# so, lets remove the numcrew column 
newdat$numcrew=NULL
head(newdat,2)

# Or alternatively we can use square brackets and '-' sign 
#  to remove columns
# lets try removing "days" variable which is in column number 5
newdat = newdat[, -5]
head(newdat,2)

# if we wanted to remove multiple columns rather than 
#  writing -5 we could write -c(4,5)

# Alternatively, we can use subset function to remove columns 
#  using the actual column name and  a negative sign:
newdat = subset(newdat, select=-monthnum)
head(newdat,2)


# dplyr way
subdat1=newdat%>%select(-c(month,vessel))
head(subdat1,2)


# Another useful function - the "grep" function

# There are also some other functions that can be helpful 
#  to find column names and numbers. 
# For example, if we don't know the full name of the 
# column we can use grep() which is a pattern matching function.
grep("vessel", names(dat))
## This means it must be column 4

# We don't even need to know the full pattern that we are 
#  looking for, For example, we can search for "vess" rather
#  than the full word "vessel"
grep("vess", names(dat))


## This function can be useful if looking for multiple columns.
# For example, let's look for all columns with the word "cpue" 
# in their name.
grep("cpue", names(dat))
# so columns 8 and 9 have cpue in their names


# So if we were wanting to keep only those columns with "cpue" 
#  in the name
newdat2 = dat[, grep("cpue", names(dat))]
head(newdat2,2)


# And if we were wanting to remove all columns with "cpue" 
#  in the name
newdat3 = dat[, -grep("cpue", names(dat))]
head(newdat3,2)
```


<br>

## Student task 3
* Create a new data frame equal to dat
* For the new data frame, create the variable 'mid.year' which represents
halway thru the year (i.e. year +0.5)
* Remove all cpue variables,
* calculate cpue3 as the catch of each record divided by the average
number of days (i.e. mean(days))
* Keep only the variables 'cpue3' and 'year'  (in this order)

Do it first using base packages

Repeat using dplyr and pipes

<br>


```{r}
#3 Select/remove rows (observations)

#base packages approach
table(dat$month)
subdat3 = dat[which(dat$month=="Feb"), ]
table(subdat3$month)
  # or
subdat3 = dat[dat$month=="Feb", ]
table(subdat3$month)
  #or
subdat3 = subset(dat,month=="Feb")
table(subdat3$month)

#dplyr approach
subdat3 = dat%>%filter(month=="Feb")
table(subdat3$month)


# To select observations based on multiple values of one variable

#base packages approach
subdat3 = dat[which(dat$month=="Feb"|dat$month=="Mar"), ]
table(subdat3$month)

  # or alternatively, we can use the operator %in% in place 
    #  of multiple OR statements
subdat3 = dat[which(dat$month%in%c("Feb","Mar")), ]
table(subdat3$month)

subdat3 = subset(dat,month%in%c("Feb","Mar"))
table(subdat3$month)

#dplyr approach
subdat3 = dat%>%filter(month%in%c("Feb","Mar"))
table(subdat3$month)


# To select observations based on values of more than one variable
#base packages approach
subdat3 = dat[dat$month%in%c("Feb","Mar") & dat$vessel=="A001", ]
table(subdat3$month,subdat3$vessel)

#dplyr approach
subdat3 = dat%>%filter(month%in%c("Feb","Mar") & vessel=="A001")
table(subdat3$month,subdat3$vessel)

#same outcome..just using ',' instead of '&'
subdat3 = dat%>%filter(month%in%c("Feb","Mar") , vessel=="A001")
table(subdat3$month,subdat3$vessel)


```


<br>

## Student task 4
* Create a new data frame equal to dat
* For the new data frame, create the variable 'mean.catch' which is the average catch of all records
* Then, remove all records from January and March
and from vessels with less tan 4 crew (tip numcrew>3)
* Finally, keep only the variables 'vessel' and 'mean.catch'

Do it first using base packages

Repeat using dplyr and pipes

<br>

```{r}
#4 Change the ordering of the observations

## In the base packages we can use the function "sort" and "order" 
dat$days
sort(dat$days)

# What if want to sort not just the days column 
#  but the entire data.frame (all columns) based on the value 
#  of the "days" variable. 
#To do this, we use "order" 
head(dat%>%select(-c(cpue1,cpue2)))
dat = dat[order(dat$days), ]
head(dat%>%select(-c(cpue1,cpue2)))
#Notice how the row numbers look all mixed up now!

## sort/order by numcrew and catch
head(dat%>%select(numcrew, catch))
dat = dat[order(dat$numcrew,dat$catch), ]
head(dat%>%select(numcrew, catch))

## How about ordering by a character vector?
dat$month[order(dat$month)]
## Uh, oh it sorts alphabetically!
## If you want to sort by character vectors, 
# you will need to convert them to a factor 
## and specify the order of the levels.
unique(dat$month)
dat$month=factor(dat$month, 
                 levels=c("Jan", "Feb", "Mar")) 
## use levels=month.abb to get all 12 months

## And now lets try that again!
dat$month[order(dat$month)]
dat[order(dat$month), -c(8:9)]


# So, to sort by month
dat = dat[order(dat$month), ]
dat[,-c(8:9)] 

#The "order" function, by default, sorts by ascending order. 
# This means that numeric variables will be sorted from lowest
#   to highest, character variables will be sorted 
#   in alphabetic order, and factors will be sorted by order
#   of their levels. 
# You can also choose to sort by descending order, by using 
# the argument decreasing=TRUE.
head(dat[,-c(8:9)],4)
dat = dat[order(dat$year, decreasing=TRUE), ]
head(dat[,-c(8:9)],4)

#dplyr approach for ordering
head(dat[,-c(8:9)],4)
dat = dat%>%arrange(monthnum,vessel)
head(dat[,-c(8:9)],4)

```


<br>

## Create summary statistics of variables within a given table
* There are many times that we are interested in creating summary statistics from a 
given data set.
* Typically, this set of summary statistics may be required for a 
given grouping of variables. 
* For example, we may want to count the number of fishing 
trips in a year, or the sum of the catch by method of fishing within each year.
* Or we may want to calculate the mean catch rate for each year, or even for each vessel 
within each year. 
* For this purpose, there are a number of functions that we can use to produce summary tables for our data.


```{r}
# 1. The "table" function
# this function counts the number of data (rows in our data frame)  
#  for the given variable (column name).

#Let's count the number of records per year
table(dat$year)

#And how about the number of records per month
table(dat$month)

#And now the number of records per vessel
table(dat$vessel)

# We can do this for multiple variables at a time
# Let's count the number of records by year and month
table(dat$year, dat$month)
# or we can flip the year and month variables
table(dat$month, dat$year)

# What about three variables?
table(dat$year, dat$month, dat$vessel)
# ...a little messy

# And remember that the order of variables makes a 
# difference to the output
table(dat$year, dat$vessel, dat$month)

# My suggestion is that the "table" function is great 
#  for one or even two variables but may be a little
#  confusing for 3 or more variables.


# It is worth noting that the table function can treat
#  NA's, i.e. missing values in, different ways. 
# By default it actually excludes them!
## Lets look at the numcrew variable...
dat$numcrew[1]=NA

table(dat$numcrew)
table(dat$numcrew,useNA = 'always') 


# Note, You can also plot table objects i.e. 
#  the output from the table command using 
#  the generic "plot" function. 
#  A 1-dimensional table (i.e. 1 variable) will plot as 
#  type "h" which are skinny histogram-like vertical lines.
table1 = table(dat$month)
plot(table1)

# 2-dimensional tables (i.e. 2 or more variables) plot as 
# mosaic plots
table2 = table(dat$year, dat$month)
plot(table2, col=2:4)

#2-dimensional tables
table3 = table(dat$year, dat$month, dat$vessel)
plot(table3, col=2:3)

# So the "table" function is great if you want to know how many 
#  data observations for a variable.


# 2. Other summary functions

# Base functions - tapply and aggregate
#  These functions can calculate the sum, or the average, 
#   or various other mathematical quantities of a given 
#  variable for various levels of another variable or variables.
#  Basically you need to tell tapply or aggregate 3 things:
# (1) Our variable of interest, e.g. catch
# (2) Our grouping variable, e.g. by year, or by year and month
# (3) The mathematical function, e.g. sum or average or count or...  


## "tapply" 


# When our data is in a dataframe, this function is 
#  very easy to use.
# Basically "tapply" (and "aggregate" below) are like the
#  pivot table functions in Excel. 
# We just have to tell the function which column/s of the 
#  dataframe to use for steps (1) and (2), and what 
#  function to use in step (3).
# So, to sum up the catch for each year in our data set, we have:
# (1) Our variable of interest is catch so the column is dat$catch
# (2) Our grouping variable is year so the column is dat$year
# (3) the function is sum, which is a built-in function in R.

# Remember the order in this function is:
# (1) VARIABLE, (2) GROUPING VARIABLE, (3) FUNCTION

#try our tapply function to sum up the catch in each year
newdat=subset(dat, !is.na(catch))
tapply(X=newdat$catch, INDEX=newdat$year, FUN=sum) 

# you dont need to write the names for these arguments...
tapply(newdat$catch, newdat$year, sum)


# Now we can extend the "tapply" function to group by multiple variables
# Note that the grouping variable or variables must be written as a list.
# This means we write list(dat$year, ...)
tapply(newdat$catch, list(newdat$year, newdat$month), sum)

#...and now grouping by 3 variables
tapply(newdat$catch, list(newdat$year, newdat$month, newdat$vessel), sum)
#...same as for table function - starts looking messy.


## Lets try our "tapply" on original data when there's NAs
dat$catch[2]=NA

#by year
tapply(dat$catch, list(dat$year), sum)
#so one of the 2015 records is NA, 
# this affects to the entire 2015 records

#fix it
tapply(dat$catch, list(dat$year), sum, na.rm=TRUE)


## by year and month
tapply(dat$catch, list(dat$year, dat$month), sum)
tapply(dat$catch, list(dat$year, dat$month), sum, na.rm=TRUE)


# Sometimes the tapply command starts looking a little verbose
#  with the data.frame name repeated. 
# We can abbreviate this using the "with" function...
with(dat, tapply(catch, list(year, month), sum, na.rm=TRUE))

# This abbreviation via the "with" function can be quite useful 
#  when you wish to subset the main data set.
with(subset(dat, year>2014), 
     tapply(catch, list(year, month), sum, na.rm=TRUE))


# You can use any function within the tapply function that 
#  takes one input and returns a single output. For example:
# sum, mean, min, max, length, sd and so on. 
with(dat, tapply(cpue1, list(year, month), mean, na.rm=TRUE))
with(dat, tapply(cpue1, list(year, month), sd, na.rm=TRUE))


# How about the number of records i.e. function is "length" 
# (length function= 'count' function in excel)
tapply(dat$cpue, list(dat$year), length, na.rm=TRUE)
# Oops, the length function doesnt accept this na.rm=TRUE argument. 
tapply(dat$cpue, list(dat$year), length)

# But without removing NAs, it counts the extra row as a data point??
# So how would we calculate the number of records per year, 
# but omitting row 2 i.e. the catch=NA?? There are a number of ways:
# (1) you could subset the data: 
with(subset(dat, !is.na(cpue1)), tapply(cpue1, 
                                        list(year, month), length))
# (2) you could write your revised "length" function to count 
#    non-NA observations
CalcLengthRevised=function(x)
{
  result=length(x[!is.na(x)])
  return(result)
}
tapply(dat$cpue1, list(dat$year), CalcLengthRevised)
#so here we wrote our own function for use in tapply

#other useful user-built function:
CalcStdError=function(x)
{
  stderror=sd(x)/sqrt(length(x))
  return(stderror)
}
with(newdat, tapply(cpue1, list(year), CalcStdError))


## Now, lets have a look at the output of tapply
table1=tapply(newdat$catch, list(newdat$year), sum)
table1
## If we look at the structure of the output object, 
# its a bit confusing.
str(table1)
## Lets look at a tapply output with 2 grouping variables
table2=tapply(newdat$catch, list(newdat$year, newdat$month), sum)
table2
## The structure is still a bit confusing.
str(table2)
## and so on for 3 grouping variables
table3=tapply(newdat$catch, list(newdat$year, newdat$month,
                                 newdat$vessel), sum)
table3

# This type of object is called an array, with the levels
# of the grouping variables (i.e. year, month, vessel...) 
# being the dimension names.


#  "aggregate" 

# The "aggregate" function essentially performs the same 
#  function as the "tapply" function but returns the result
#  in a different format which is often a lot easier to work
#  with in our analyses. 
# The output of the aggregate function is another data.frame
# As for the tapply function, we need to define
# (1) the variable of interest
# (2) the grouping variable/s 
# (3) the function to apply to the variable of interest
#     for each combination of the grouping variables.

#tapply version
with(newdat,tapply(catch, list(year), sum))

#aggregate version
with(newdat,aggregate(catch, list(year), sum))

#...but better to give names to new columns
with(newdat,aggregate(data.frame(catch=catch), list(year=year), sum))

# there is also a 'formula' version of aggregate
aggregate(catch~year, newdat, sum)


#As for tapply, you can write your own function if needed
CalcStdError
aggregate(cpue1~year, newdat, CalcStdError) 


# The aggregate function also has the ability to calculate 
#  summary statistics for multiple variables.
# For example, we could calculate the total catch per and
#  total number of fishing days per year by 
aggregate(cbind(catch, days)~year, newdat, sum)

# As for the tapply function, we can group over multiple variables
# Lets group over year and month
aggregate(catch~year+month, newdat, sum)
# Or year and vessel
aggregate(catch~year+vessel, newdat, sum)



# Let's do some calculations that are actually meaningful..

# Calculate the total catch per year, 
#  and the average catch rate per year
aggregate(catch~year+vessel, newdat, sum)
aggregate(cpue1~year+vessel, newdat, mean)
#...it would be nice to combine these into one output.
# we can do this with "merge".


# The "merge" function
#  First calculate the total catch per year via aggregate.
agg1=aggregate(catch~year+vessel, newdat, sum)
agg1
#  Now calculate the average catch rate per year via aggregate.
agg2=aggregate(cpue1~year+vessel, newdat, mean)
agg2

#  Combine these 2 data sets (agg1a and agg1b) as they have 
#    the year and vessel columns in common. 
aggcomb1=merge(agg1, agg2, by=c("year", "vessel"))
aggcomb1

# Lets try another example:
# Say we would like to calculate the average catch rate per year,
#  and in addition, calculate the confidence intervals
agg3=aggregate(cpue1~year+vessel, newdat, mean)
agg3
agg4=aggregate(cpue1~year+vessel, newdat, CalcStdError)
agg4

# As before, we would like to combine these 2 data sets 
# Problem: the 3rd column in each of the data 
#          sets is called "cpue". 
aggcomb2=merge(agg3, agg4, by=c("year", "vessel"))
aggcomb2

#Let's fix it
agg4
names(agg4)[which(names(agg4)=="cpue1")]="cpue.se"

# Now merge 
aggcomb2 = merge(agg3, agg4, by=c("year", "vessel"))
aggcomb2


# And now we can plot the cpue by year and vessel with 
# confidence intervals
#  First lets calculate the lower and upper confidence limits.
aggcomb2$lowCL = aggcomb2$cpue1 - 1.96 * aggcomb2$cpue.se
aggcomb2$uppCL = aggcomb2$cpue1 + 1.96 * aggcomb2$cpue.se
aggcomb2

#  And now to plot the cpue by year with confidence intervals
plot(aggcomb2$year, aggcomb2$cpue1, "n", ylim=c(0, 40), 
     axes=FALSE, las=1, xlab="Year", ylab="CPUE")
for (ivessel in unique(aggcomb2$vessel))
{
  subdat=subset(aggcomb2, vessel==ivessel)
  ivesselnum=which(unique(aggcomb2$vessel)==ivessel)
  lines(subdat$year, subdat$cpue1, "o", pch=16, lty=2,
        col=ivesselnum+1)
  arrows(subdat$year, subdat$lowCL, subdat$year,
         subdat$uppCL,code=3, angle=90, length=0.02,
         col=ivesselnum+1)
}
axis(1, at=2014:2016)
axis(2, at=seq(0, 40, 10), las=2)
legend("topright", legend=unique(aggcomb2$vessel), 
       pch=16, lty=2, col=2:3, 
       bty="n", cex=0.8)


```

<br>

## Student task 5
* Create a new data frame equal to dat
* Calculate mean and SE of the variables 'days' and 'catch' by 'year'
* In one page, Plot mean days (and 95% CI) by year and mean catch (and 95% CI) by year 

<br><br>


## Summarising in the "dplyr" package - group_by and summarise

- We've seen how to produce summary statistics using the tapply and aggregate functions available in the base package.

- Now lets see how to do the same thing using the functions of the dplyr package. The 2 new function we will need are "summarise" and group_by.

```{r}
# Let's repeat the aggregate command we used previously to calculate the 
# sum of the catches by vessel and year
agg1=aggregate(catch~year+vessel, newdat, sum)
agg1

newdat$cpue=newdat$cpue1
dat$cpue=dat$cpue1

# dplyr way
#   First we group the data,
#   then we calculate the summary stastics
group.data=newdat%>% group_by(year, vessel)%>%
                      summarise(catch = sum(catch))
# The output of summarise is a slightly different
# format than aggregate. Its called a tibble and is 
#  somewhat like a data.frame. 
# In fact, it can easily be converted to
## a data.frame 
group.data=newdat%>% group_by(year, vessel)%>%
                     summarise(catch = sum(catch))%>%
                     data.frame

#Just as in tapply and aggregate we can use a 
#  range of functions within the summarise
# command like sum, mean, min, max etc. 
#However, summarise actually allows different
# functions to be applied to different variables. 
#For example, we can calculate the
#   mean of the catch rates, but we can also 
# calculate the sum of the catches. 
summarydat2 = newdat %>%
             group_by(year, vessel) %>%
             summarise(catch=sum(catch), cpue=mean(cpue)) %>%
             as.data.frame
summarydat2


#Now let's add the calculation of the standard
#  errors of the cpues and then their
#  confidence limits. 
#Note that in this calculation I have renamed the 
#  average cpue to cpue.mean. 
#This needs to be done as I want to undertake another
#  calculation of the original cpue variable (i.e. the
#  standard error) and the function will get confused
#  with the original cpue variable and the new average 
#  value if we use the same name.
summarydat3 = newdat %>%    
              group_by(year, vessel) %>%
              summarise(catch=sum(catch), 
                        cpue.mean=mean(cpue),
                        cpue.se=CalcStdError(cpue)) %>%
              mutate(lowCL = cpue.mean-1.96*cpue.se,
                     uppCL = cpue.mean+1.96*cpue.se) %>%
              as.data.frame
summarydat3

#Integrate the filter function within our piping
#  code to use the original data and subset 
#  for non-NA values. 
# In addition, rather than writing our own function
#  to compute the standard error we could simply
#  calculate this within our piping code also

summarydat4 = dat %>%
        filter(!is.na(catch)) %>%
        group_by(year, vessel) %>%
        summarise(catch=sum(catch), 
                  cpue.mean=mean(cpue), 
                  cpue.sd=sd(cpue), 
                  n=n()) %>%
        mutate(cpue.se=cpue.sd/sqrt(n), 
               lowCL=cpue.mean-1.96*cpue.se, 
               uppCL=cpue.mean+1.96*cpue.se) %>%
        as.data.frame
summarydat4
```

<br>
## Student task 6
- Try importing the other 'fake' fisheries catch and effort data set called
 "Lesson5_fisheries catch and effort data v2.csv"
- Get the mean and SD of total catches by year and month using the tapply function. Then recalculate using the aggregate function.
- Create a table of average catch rate (catch/days) by vessel including their 95% confidence intervals (assuming a normal distribution). You can choose to use the aggregate function or the dplyr functions using piping code to do this.
- Plot the catch rates from with their 95% confidence intervals.

<br>

## reshaping and merging
```{r}
# tidyverse and piping version
library(tidyverse)
# this loads several packages, including tidyr

    # joining data frames
band_members
band_instruments

band_members %>% 
  inner_join(band_instruments)%>%
  data.frame

band_members %>%
  left_join(band_instruments)%>%
  data.frame

band_members %>%
  right_join(band_instruments)%>%
  data.frame

band_members %>%
  full_join(band_instruments)%>%
  data.frame

    #gathering (long format)
stocks <- data.frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4))
stocks

D1=gather(stocks, "stock", "price", -time)
head(D1)
D2=stocks %>% gather("stock", "price", -time) #same...
head(D2)

mini_iris <-  iris %>%
              group_by(Species) %>%
              slice(1) %>%  #choose the first 
                            # row of each Species
              data.frame
mini_iris %>% gather(key = "flower_att",
                     value = "measurement", -Species)


    #spread  (wide format)
 #long version
head(D1,3)

  #wide version
D1 %>% spread(stock, price)


# with base R, it can be done with reshape() and 
#   merge()...
# try by yourself...
#search ?reshape() and ?merge() and repeat what we
#  have just done with dplyr...

```


<br>
tidyverse cheat sheet
https://rstudio.com/resources/cheatsheets/


# Base times and dates
```{r}
silly.dates <- c("12/22/2003","02/06/2005","04/08/2005")
silly.dates       # these are just character strings

silly.dates2 <- c("12/22/03","02/06/05","04/08/05")
silly.dates2 

# the function strptime() strips a date out
#  of a character string by assuming 
# the date is encoded according to the format
# you specify in "quotes". 
# The % sign preceeds a single letter code for what 
# variable is next and then after
# that is whatever else will occur in the character 
# string before the next time variable. 

dates = strptime(silly.dates2,format="%m/%d/%y")  
dates
   
strptime(silly.dates,format="%m/%d/%y") 
# whooops! ...putting a 2020 at the start of each date!

# we need to tell strptime the correct format: the 
#  year is abbreviated to two digits. 
# Use %Y, NOT %y 
strptime(silly.dates,format="%m/%d/%Y")

# Getting the dates into R is just the first step. 
# We may very well want to extract the year, month and day.
# This can be done with the substr()
# function as follows:

dates
years = substr(dates, 1,4)    # characters 1 to 4 of dates
years
months = substr(dates, 6,7)   # characters 6 to 7 of dates
months
days = substr(dates,9,10)
days 

# now let's read in a text file with dates
# and other data. Here, the dates & 
# time are in 7 separate columns
d <- read.csv(paste(hndl,"Lesson5_temp-time.csv",sep=""),header=T)
d
attach(d)
dim(d)
# The data set consists of several columns 
# indicating time and one response variable, temperature. 

# We need to write time so that it can be handled by R.

# First let's join together in the proper format the 
#   hours, minutes and seconds
time.of.day <- (paste(hour,min,sec,sep=":"))
time.of.day
# Now let's add the time zone (separated by a space)
time.of.day.VA <- paste(time.of.day,meridian,sep=" ")
time.of.day.VA
# The date gets formed by grouping together year, 
#  month and day in that order, separated by a dash.
day.of.year <- paste(year,month,day,sep="-")
day.of.year
date.complete <- paste(day.of.year,time.of.day.VA,sep=" ")
date.complete

# There are two basic classes for date and time
# POSIXct gives you the number of seconds passed 
#  since Jan1, 1970 (Think ct = cumulative time)
# POSIXlt gives you dates in a form that can be 
#   broken down (using the unclass() function) 
#   into a list of vectors representing sec, min,hrs,
#    day,month,year (Think lt = list of time elements)
# year is scored as number of years since 1900 so 
#  that 2008 gets a score of 108
# mday = day number within the month
# mon is the month but January is scored as zero, 
#    so September is 8 not 9
# wday is the day of the week starting with 
#    Sunday with a score of 0
# yday is the day of the year starting with 
#    January 1 with a score of 0
# isdst returns whether daylight savings time 
#    is in operation

# POSIXlt function
date.complete
date1lt <- as.POSIXlt(date.complete)
date1lt    
# note the very slight difference between date.complete 
#  and date1lt
unclass(date1lt[1])
unlist(unclass(date1lt[1]))
# The output of the function unlist is not very 
# attractive.  It is very difficult to read it.
# However, it might be useful if we are interested in
# looking at one particular observation. 

unlist(unclass(date1lt[5])) 
# this is a vector representing all the
# information for the 5th record

is.vector(unlist(unclass(date1lt[5])))

unclass(date1lt[5])     # this is a list
is.list(unclass(date1lt[5]))

# POSIXct function
date1ct <- as.POSIXct(date.complete)
date1ct
unclass(date1ct[4:5])

# Calculations with dates and times

# R will allow you to do some operations with time
# You can do addition and substraction of two times. 
# You can also add or substract a constant, 
# multiply or divide by a constant.
# However, multiplication of two times, power, log, etc. 
#  are not possible.  
# In order to do them, you need to reverse the time to 
#  numeric using the as.numeric function.
# Logical operations such as <=, =>, etc. are 
#  also possible with time.


# How many shoppings days are left until Christmas?
Christmas <- as.POSIXlt("2019-12-25")
Christmas
today <- as.POSIXlt("2019-10-09") 
today
Shopping.days <-Christmas-today
Shopping.days
# How many days until Boxing day?
Shopping.days + 1

# We can do the following arithmetic with dates:
#   time + number
#   time - number
#   time1 - time2 (or time2 - time1)
#   time1 'logical operation' time2
# where logical operation can be ==, !=, <, <=, etc.

# Suppose we're really interested in the log of 
#  number of days until Christmas
log(Shopping.days)
num.days <- as.numeric(Shopping.days)
num.days
log(num.days)


# How many seconds until the end of class?
end <-as.POSIXlt("2019-10-09 18:00:00")    
end
start<- as.POSIXlt("2019-10-09 09:00:00")
start
number.sec <- round(as.numeric((end-start)*3600 ),digits=0)
cat(paste("There are ",number.sec,
          " seconds until the end of class","\n"))

# Use of the difftime function
# If J.S.Bach was alive today, how many 
#  days old would he be?
difftime("2008-11-19","1685-03-31")

```

<br>

# Package Lubridate 

source:

https://rpubs.com/mr148/303800

```{r}
library(lubridate)

df <- data.frame(Date = c("10/9/2009 0:00:00", 
                          "10/15/2009 0:00:00"))
 as.Date(df$Date, "%m/%d/%Y %H:%M:%S")

mytime<-ymd_hms("2015-08-14-05-30-00", 
                tz="America/Halifax")
mytime

#get just the date part
date(mytime)

#Check for Time Intervals
date1<-ymd_hms("2017-06-20-03-45-23")
date2<-ymd_hms("2017-10-07-21-02-19")
difftime(date2,date1)

#get current date or time
lubridate::today()  #why the 'lubridate::' bit?
                    # this tells to use the function today()
                    # from the lubridate package
base::date()
Sys.Date()
Sys.timezone()
now()

#Extract day,month,year from date
year=year(today())
month=month(today())
day=day(today())
cbind.data.frame(year,month,day)


#extract hour and minutes
mytime
hour(mytime)
minute(mytime)

```

<br>

# Conditionals and program flow
```{r}
decision <- T

if (decision==T) cat("\n\nMatias is a GREAT professor")
if (decision) cat("\n\nMatias is a GREAT professor")
decision

decision <- F
if (decision==F) cat("\n\nJavier is a GREAT professor")
if (!decision) cat("\n\nJavier is a GREAT professor")
decision

# We can include multiple statements in an if() construct
# if we enclose them in braces {  }.  
#  Also, we can nest if statements
decision <- 1
if(decision==1)
{
  junk <- 14
  for (i in 1:5)
  {
   cat("\nMatias is a GREAT professor",i)
  }
} else
{
  A <- "Oh"
  B <- " wow!"
  Sorry <- ", Javier is not!"
  cat("\n",A,B,Sorry)
}

decision <- 2
if(decision==1)
{
  junk <- 14
  for (i in 1:5)
  {
   cat("\nMatias is a GREAT professor",i)
  }
} else
{
  A <- "Oh"
  B <- " wow!"
  Sorry <- ", Javier is not!"
  cat("\n",A,B,Sorry)
}

# There's also a function ifelse(test,ifyes,ifno)
values = c(3,1,5,6,2,7,5)
sex = ifelse(values <= 4,"F","M") 
# if values is < or = to 4, sex is assigned "F"
#  otherwise it is assigned "M"
values
sex

# Let's contrast several ways of controlling 
#  program flow: for, while and repeat

# calculate x! = x(x-1)(x-2)...(2)(1)
# NOTE: 1! = 1
# NOTE: 0! = 1

fac1 <- function(x){
  f <- 1
  if(x<2) return(1)
  for (i in 2:x) {
    f <- f*i
  }
  return(f)
}

fac1(3)
sapply(0:5,fac1)
# don't worry about the sapply function. Just accept (for now)
# that it will apply the function fac1 to each of the numbers
# in the sequence 0, 1, 2, 3, 4, and 5. We use it here to test
# out our function fac1

fac2 <- function(x) {
  f <- 1
  t <- x
  while(t>1) {
    f <- f*t
    t <- t-1
  }
  return(f)
}

fac2(3)
sapply(0:5,fac2)

fac3 <- function(x) {
  f <- 1
  t <- x
  repeat{
    if (t<2) break
    f <- f*t
    t <- t-1
  }
  return(f)
}

fac3(3)
sapply(0:5,fac3)

cumprod(1:5)
cumprod(0:5)

fac4 <- function(x) max(cumprod(1:x))

fac4(3)
fac4(1)
fac4(0)
```

<br>

# Apply family
source:
https://www.datacamp.com/community/tutorials/r-tutorial-apply-family

Overall, the apply function is a wrapper of looping
The apply() functions form the basis of more complex combinations and helps to perform operations with very few lines of code. More specifically, the family is made up of the apply(), lapply() , sapply(), vapply(), mapply(), rapply(), and tapply() functions.

We already learnt about tapply()..let's have a look at the others..

```{r}
#1. apply
#  construct a 5x6 matrix
 X <- matrix(rnorm(30), nrow=5, ncol=6)

# sum the values of each column with `apply()`
apply(X, 2, sum)

#2. lapply
#used for applying a given function to every element 
# of a list and obtain a list as a result

# create a list of matrices
 MyList <- list(A=matrix(rnorm(10), nrow=5, ncol=2),
                B=matrix(rnorm(10,5,1), nrow=5, ncol=2),
                C=matrix(rnorm(10,100,10), nrow=5, ncol=2))
 MyList
 
# extract the 2nd column from `MyList` with the selection
 #  operator `[` with `lapply()`
lapply(MyList,"[", , 2)

# extract the 1st row from `MyList`
lapply(MyList,"[", 1, )

# extract first row and second column
lapply(MyList,"[", 1, 2)

#3. sapply
# a simplified version of lapply
  #this returns a list
lapply(MyList,"[", 2, 1 ) 

  #this returns a vector
sapply(MyList,"[", 2, 1 ) 

#4. mapply
# stands for ‘multivariate’ apply; it applies a Function to 
# Multiple List or multiple Vector Arguments (e.g. a matrix)

Q1 <- matrix(c(rep(1, 4), rep(2, 4), rep(3, 4), rep(4, 4)),4,4)
Q1

Q2 <- mapply(rep,1:4,4)
Q2

```



