---
title: "Lesson 5. Data manipulation and looping"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "C:/Matias/Cursos/2019_Mexico/htmls") })

output: 
  html_document:
    code_folding: show
    highlight: haddock
    keep_md: yes
    theme: united
---

<style type="text/css">
h1.title {
  font-size: 30px;
    color: Maroon;
  text-align: center;
          }
h3.subtitle {
  font-size: 22px;
    color: Maroon;
  text-align: center;
            }
h4.author { 
    font-size: 24px;
      color: FireBrick;
  text-align: center;
          }
h4.date { 
  font-size: 18px;
  text-align: center;
        }
h1{
  font-size: 22px;
  color: DarkBlue;
  }
h2{
  font-size: 20px;
  color: Blue;
  }
h3{
  font-size: 18px;
  color: SteelBlue;
  }
body{
    font-family: Helvetica;
    font-size: 14pt;
    }
code.r{
  font-size: 16pt;
      }
pre {
  font-size: 16pt;
}
</style>


```{r globaloptions, include=FALSE}
knitr::opts_chunk$set(fig.width = 6,fig.height = 6,error=TRUE,
                        echo = TRUE, warning=FALSE,message=FALSE)
```

# Lesson goals
We're going to manipulate data, i.e. clean it, reshape it, aggregate it, use loops, etc.

<br>
Credits to John Hoenig, Ainslie Denham and Alex Hesp
<br><br>


## Data manipulation
By this I mean  anything that needs to be done to a data set in order to perform a given
analysis....

```{r}
# Let's start with a clean slate
rm(list=ls())

# Let's read in some age and length data from a .csv file 
#   and have a quick look at it
options(stringsAsFactors = FALSE)
LenAgeDat <- read.csv(
  "C:/Matias/Cursos/2019_Mexico/Data.sets/Lesson5_LenAtAgeData.csv",
  header = T)
head(LenAgeDat,2)
tail(LenAgeDat,2)

#other basic options for reading in data
#read.table()
#read.delim()
#readWorksheetFromFile() from the XLConnect package
#read_excel() from the readxl package


# what variables/fields do we have?
names(LenAgeDat)

# What areas are there in the data set? 
unique(LenAgeDat$Area)

# what sexes are there?
unique(LenAgeDat$SexNameVec)
# note: Levels in result indicates the structure type
# (text)is stored as a factor ie. Female=1 , Male =2.
# Defaults by alphabetical order

# and there is a corresponding numeric code for sex
unique(LenAgeDat$SexNumVec)
# ...seems reasonable, its not like there are 3 or 1, 
# when we know there should be 2 (females and males)


# Let's get a bit of information regarding the age data
summary(LenAgeDat$ObsAge)
# OK, a fairly short-lived fish, with maximum age of 10, 
#    with some fish caught at one.


# Let's store the min and max age
(MinAge <- min(LenAgeDat$ObsAge))
(MaxAge <- max(LenAgeDat$ObsAge))
# remember, if we put brackets around the thing, 
#  then it will print out to the console

# we can also get the range this way
AgeRange <- range(LenAgeDat$ObsAge)

# so we could also store the minimum and maximum ages 
#   as variables this way, if we wanted to
(MinAge <- AgeRange[1])
(MaxAge <- AgeRange[2])


# Let's make a vector containing our age categories,  
#  which we can use later
(AgeClasses <- seq(MinAge,MaxAge,1))

# What about length? Let's learn a bit more
summary(LenAgeDat$ObsLen)
# fish gets up to 346

# So, what would be the age composition fish for females in area 1?
# We can subset the data for female fish in area 1
SubDat <- LenAgeDat[LenAgeDat$Area==1,]
head(SubDat)
# so in LenAgeDat[LenAgeDat$Area==1,], we are saying, in the
#  data frame called 'LenAgeDat', take the rows for which the 
#  area column has a value of 1 (it is the row column because its
#  left of the comma in the square brackets). 
# In other words, think of [row,column] when you're subsetting 
#  using square brackets. 
# Because we've put nothing after the comma in the brackets, 
#  we are saying keep all the columns in the original data frame,
#  but subset for specific rows.
# Then we assign this (i.e. by using <-) to the new object 
#  called 'SubDat',

SubDat1 <- subset(LenAgeDat,Area==1)  #same result...
head(SubDat1==SubDat)


#  VIP: By using a different variable name, i.e. Subdata, rather
# than LenAgeDat, we keep the original data unchanged in memory


# how much data have we got. Looking at the environment window 
#  (topright),it says there are 157 observations for SubDat. 

# Let's check it another way
(length(SubDat$ObsAge))
(length(SubDat$ObsLen))
# so there are 157 age observations, 
# 157 length observations and so on. 
# If there were different numbers of ages and lengths, 
#  that could mean a problem, but OK here


# Another way is to check the dataframe "dimensions"
dim(SubDat)
# so the data frame has 157 rows and 5 columns


# Now, let's subset the data further, for females
SubDat <- SubDat[SubDat$SexNameVec=="Female",]
# Here, because I've used the name SubDat on both the left 
#  and right of the assingment sign (<-), we overwrite 
#  the original subsetted data (containing all data for 
#  area 1) with a data frame containing only females in area 1 

# how many observations now? Environment window says its 
#  gone down to 75.
dim(SubDat)


# We could end up with the same result produced by the 
#  above two lines of code using this single line of code, 
#  by subsetting our original data frame to contain data 
#  for only females in area 1 in a single go,
SubDat <- LenAgeDat[LenAgeDat$Area==1 & 
                      LenAgeDat$SexNameVec=="Female",]
# So here, we've asked to retain only the rows of data for 
#  which area = 1 and sex = Females. 

# Either way is fine.


# Let's look at the age and length composition data for 
# females in area 1...How many fish do we have for each age?
table(SubDat$ObsAge)

# Let's use the frequency function to plot it
AgeCats <- c(0,AgeClasses)


#before plotting...
# There is a plotting function, which specifies information
#   regarding number of plots on a page, and how they are 
#   positioned, and how much space around each plot. 
# Here, we are saying 2 plots per page
#?par
par(mfcol=c(2,1),mar=c(4,4,2,2))

#now plot the histogram
HistData=hist(SubDat$ObsAge, breaks=AgeClasses, right=FALSE,
              col="pink", main="", xlab="Age class", 
              ylab="Frequency",las=1,xlim=c(0,10))

# if we want, we can look at the ages and corresponding 
#  frequencies this way
HistData$breaks # ages
HistData$counts
# frequencies at corresponding ages (same result as from
#  table function above)


# OK, great, what about males in area 1. Let's subset again
SubDat <- LenAgeDat[LenAgeDat$Area==1 & 
                      LenAgeDat$SexNameVec=="Male",]
HistData=hist(SubDat$ObsAge, breaks=AgeClasses, right=FALSE,
              col="light blue", main="", xlab="Age class",
              ylab="Frequency",las=1,xlim=c(0,10))

#...but we seem to be repeating the same code over and over
#    again - too tedious and prone to errors.... 
#   Imagine we had 10 or 20 plots to do.... has to be a better way


# ...the alternative...use loops...

# Let's say we want to do something 5 times, e.g. start at zero and
#  add one to the number 5 times (answer should be 5, right?)

# without a loop first. 
i = 0  #Let's call the variable for our number "i"
(i = i + 1) # add one
(i = i + 1) #again
(i = i + 1) #again
(i = i + 1) #again
(i = i + 1) # one last time

#loop version
i <- 0
for (j in 1:5)
{
  i <- i + 1
}
i

i <- 0 
for (j in 1:5) i<-i+1 #same.. (don't need {} if only 1 line of code)
i

#see what the loop is doing
i <- 0
for (j in 1:5)
{
  i <- i + 1
  print(i)
}

# so, let's say we wanted to loop backwards from 5 to 1
i = 0
for (j in seq(from=5,to=1,by=-1)) {
  i = i + 1
}
i
# we get 5? Why? Well, even though we are going backwards,
#  the thing we are doing, adding 1 to i each time, is 
#  still happening 5 times
# Did we really go backwards and end up at 1? What's the 
#  value of our loop counter variable?
j
# yes, after looped, it's now at 1!


# So what's happening in the loop?
i = 0
for (j in seq(from=5,to=1,by=-1)) {
  cat("in loop number",j,"before adding one, i = ",i,"\n")
    i = i + 1
  cat("in loop number",j,"after adding one, i = ",i,"\n")
}
i
# ?cat
# ...useful for understanding what is going on when looping,
# and finding errors - or "debugging"


# say we wanted to go forwards to 1000, in increments of 2
i = 0
N=1e7
system.time({for (j in seq(from=1,to=N,by=1)) {
  i = i + 1
}})
i

#faster way
system.time(length(seq(from=1,to=N,by=1)))

#...don't always want to use loops....

```

## Student task
Try plotting a histogram of 'ObsAge' for females in area 1 and then area 2 using a loop\

Use par() to show the two histograms in one page 

<br>

## Solution to student task
```{r}
par(mfcol=c(2,1),mar=c(4,4,2,2))
for(a in 1:2)
{
  SubDat <- LenAgeDat[LenAgeDat$Area==a &
                        LenAgeDat$SexNameVec=="Female",]
  hist(SubDat$ObsAge, breaks=AgeClasses, right=FALSE,
              col="light pink", main=paste("area",a),
              xlab="Age class",ylab="Frequency",las=1,
       xlim=c(0,10))
}

```
<br>

## alternatively...what is different?
```{r}
area.vec=sort(unique(LenAgeDat$Area))
par(mfcol=c(2,1),mar=c(4,4,2,2))
for(a in 1:length(area.vec))
{
  with(subset(LenAgeDat,Area==a & SexNameVec=="Female"),hist(ObsAge,
                breaks=AgeClasses, right=FALSE,col="pink", 
                main=paste("area",a), xlab="Age class",
                ylab="Frequency",las=1,xlim=c(0,10)))
}
```
<br>
## Let's combine loops and functions to reduce number of code lines

```{r}
#let's plot females and males by area in one single page

  #first, create a function for plotting the histogram
fn.hist=function(d,CL,Area)
{
  hist(d$ObsAge,breaks=AgeClasses, right=FALSE,col=CL, 
         main=paste("area=",Area,"sex=",Sex.vec[s]),
         xlab="Age class",ylab="Frequency",las=1,xlim=c(0,10))
}
  #next, create useful vectors
Sex.vec=c("Female","Male")
CL.sex=c("pink","light blue")

  #finally, apply double loop
par(mfcol=c(2,2),mar=c(4,4,2,2))
for(s in 1:length(Sex.vec))
{
  for(a in 1:length(area.vec))
  {
    fn.hist(d=subset(LenAgeDat,SexNameVec==Sex.vec[s] & Area==a),
            CL=CL.sex[s],
            Area=a)
  } #end of area loop
} #end of sex loop

# It's good coding practice when using multiple loops to indent code,
#  line up the brackets and write a comment at the end of each 
#  closing bracket to identify which loop it belongs to 

```

<br>

## Student task
Repeat for 'ObsLen' (i.e. show histogram form each sex and area in 1 page) 
(tip, think about the break classes and xlim used in the histogram)

<br>

## Solution to student task
```{r}
LenClasses <- seq(10*floor(min(LenAgeDat$ObsLen)/10),
                  10*ceiling(max(LenAgeDat$ObsLen)/10),10)
fn.hist=function(d,CL,Area)
{
  hist(d$ObsLen,breaks=LenClasses, right=FALSE,col=CL, 
       main=paste("area=",Area,"sex=",Sex.vec[s]),
       xlab="Size class",ylab="Frequency",las=1,
       xlim=c(0,max(LenClasses)))
}

  #finally, apply double loop
par(mfcol=c(2,2),mar=c(4,4,2,2))
for(s in 1:length(Sex.vec))
{
  for(a in 1:length(area.vec))
  {
    fn.hist(d=subset(LenAgeDat,SexNameVec==Sex.vec[s] & Area==a),
            CL=CL.sex[s],
            Area=a)
  } #end of area loop
} #end of sex loop


# Let's do a scatter plots, to show the length at age data,
#   for each sex in each area
par(mfcol=c(2,2),mar=c(4,4,2,2))
for (s in 1:length(Sex.vec))
  {
    for (a in 1:length(area.vec))
      {
        d=subset(LenAgeDat,SexNameVec==Sex.vec[s] & Area==a)
        plot(d$ObsAge,d$ObsLen, pch=16, cex=0.8, col=CL.sex[s], 
             main=paste("area=",a,"sex=",Sex.vec[s]),
             xlab="Age class (years)", ylab="Length (mm)",las=1,
             xlim=c(0,10), ylim=c(0,400))

  }
}

```
<br><br>

## Enter package dplyr

```{r}
library(dplyr)  #load this library, we will use it shortly..


# SECTION 1: Read in data
# In order to do some data management, we need to have some  
#   actual data that we can manage, so lets import some data to use.

# First, have a look at what's in the current 
dir()
list.files()

hndl="C:/Matias/Cursos/2019_Mexico/Data.sets/"
dat=read.csv(paste(hndl,
              "Lesson5_fisheries catch and effort data.csv",sep=""))

# This data set is completely made up. It is meant to be a very
#  simple example of a fisheries catch and effort data set with each 
#  row representing a unique fishing event by a vessel in a given 
#  year and month.

#useful functions when first looking at your data
dim(dat)
str(dat)
summary(dat)

# As this data set is rather small (15 observations),
#  lets look at the whole data set
dat
# Note that I have purposefully made some errors in the data set 
#  to make it a little more real, and so that we can see how 
#  to deal with some of these errors.

#there are some missing values...
unique(dat$vessel)

# let's say these are data entry errors so we want
# to rectify them in the code
#(note: in an ideal world, we'd report it back to the data team
#    so they can change it in the database)

#say we know the missing vessel for the 27th of January 2014
#  is "A001"
dat$vessel[dat$year==2014 & dat$month=="Jan" & dat$days==27]
dat$vessel[dat$year==2014 & dat$month=="Jan" & dat$days==27]="A001"
dat$vessel[dat$year==2014 & dat$month=="Jan" & dat$days==27]

#or say we know all missing vessl records are from "A001"
dat$vessel=ifelse(dat$vessel=="","A001",dat$vessel)
unique(dat$vessel)

#alternative, we can use with() to minimize coding
dat$vessel=with(dat,ifelse(vessel=="","A001",vessel))

#missing numeric values (shown as NA)
unique(dat$numcrew)
unique(dat$catch)

dat$catch=with(dat,ifelse(is.na(catch),mean(catch,na.rm=T),catch))
dat$numcrew=with(dat,ifelse(is.na(numcrew),round(mean(numcrew,na.rm=T)),numcrew))

unique(dat$numcrew)
unique(dat$catch)
```

<br>

## Basic data manipulation
* 1 Add new variables (e.g. calculate catch rate = catch/effort)
* 2 Select/remove columns (variables)
* 3 Select/remove rows (observations)
* 4 Change the ordering of the observations

```{r}
# 1 Add new variables
  #using base package (what we've been doing so far)
dat$cpue1 = dat$catch/dat$days
head(dat,2)

  #using dplyr (better coding practice...)
dat=mutate(dat, cpue2 = catch/days)

dat$cpue1
dat$cpue2

  #using piping and dplyr (much better codding practice)
dat1=dat%>%mutate(cpue=catch/days)

```
## PIPING  uses the pipe operator which looks like this  '%>%'
* The dplyr package imports this operator from another package (magrittr). 
* This operator allows you to pipe the output from one function to the input of another
function.
* Instead of nesting functions (reading from the inside to the outside), the
idea of of piping is to read the functions from left to right


basic tutorial on how to use pipes
https://www.datacamp.com/community/tutorials/pipe-r-tutorial#howto


```{r}
# 2 Select/remove columns (variables)

# Some ways to SELECT one or more columns
#   base packages approach
subdat1 = dat[, c("year", "month", "cpue1")]
head(subdat1,2)
    # or 
subdat1 = dat[, c(1,2,8)]
head(subdat1,2)
    # or
subdat1 = data.frame(year=dat$year, month=dat$month, cpue1=dat$cpue1)
head(subdat1,2)
    #or
subdat1 = subset(dat, select=c(year, month, cpue1))
head(subdat1,2)

#  dplyr
subdat1=dat%>%select(year, month, cpue1)
head(subdat1,2)


# Some ways to REMOVE one or more columns
#First let's save our data set to a new name so we don't delete all 
# our data, i.e. let's just make a copy of our data
newdat=dat
head(newdat,2)

# To remove a single column, we can set the column equal to NULL
# so, lets remove the numcrew column 
newdat$numcrew=NULL
head(newdat,2)

# Or alternatively we can use square brackets and '-' sign 
#  to remove columns
# lets try removing "days" variable which is in column number 5
newdat = newdat[, -5]
head(newdat,2)

# if we wanted to remove multiple columns rather than 
#  writing -5 we could write -c(4,5)

# Alternatively, we can use subset function to remove columns 
#  using the actual column name and  a negative sign:
newdat = subset(newdat, select=-monthnum)
head(newdat,2)


# dplyr way
subdat1=newdat%>%select(-c(month,vessel))
head(subdat1,2)


# Another useful function - the "grep" function

# There are also some other functions that can be helpful 
#  to find column names and numbers. 
# For example, if we don't know the full name of the 
# column we can use grep() which is a pattern matching function.
grep("vessel", names(dat))
## This means it must be column 4

# We don't even need to know the full pattern that we are 
#  looking for, For example, we can search for "vess" rather
#  than the full word "vessel"
grep("vess", names(dat))


## This function can be useful if looking for multiple columns.
# For example, let's look for all columns with the word "cpue" 
# in their name.
grep("cpue", names(dat))
# so columns 8 and 9 have cpue in their names


# So if we were wanting to keep only those columns with "cpue" 
#  in the name
newdat2 = dat[, grep("cpue", names(dat))]
head(newdat2,2)


# And if we were wanting to remove all columns with "cpue" 
#  in the name
newdat3 = dat[, -grep("cpue", names(dat))]
head(newdat3,2)
```


<br>

## Student task
* Create a new data frame equal to dat
* For the new data frame, create the variable 'mid.year' which represents
halway thru the year (i.e. year +0.5)
* Remove all cpue variables,
* calculate cpue3 as the catch of each record divided by the average
number of days (i.e. mean(days))
* Keep only the variables 'cpue3' and 'year'  (in this order)

Do it first using base packages

Repeat using dplyr and pipes

<br>

## Solution to student task
```{r}
#base packages solution
dat1=dat
dat1$mid.year=dat1$year+0.5
dat1=dat1[, -grep("cpue", names(dat1))]
dat1$cpue3=dat1$catch/mean(dat1$days)
dat1=dat1[,c("cpue3", "year")]

#dplyr solution
dat2=dat%>%mutate(mid.year=year+0.5)%>%
          select(-grep("cpue", names(dat)))%>%
          mutate(cpue3=catch/mean(days))%>%
          select(cpue3, year)

head(dat1,3)
head(dat2,3)

```

```{r}
#3 Select/remove rows (observations)

#base packages approach
table(dat$month)
subdat3 = dat[which(dat$month=="Feb"), ]
table(subdat3$month)
  # or
subdat3 = dat[dat$month=="Feb", ]
table(subdat3$month)
  #or
subdat3 = subset(dat,month=="Feb")
table(subdat3$month)

#dplyr approach
subdat3 = dat%>%filter(month=="Feb")
table(subdat3$month)


# To select observations based on multiple values of one variable

#base packages approach
subdat3 = dat[which(dat$month=="Feb"|dat$month=="Mar"), ]
table(subdat3$month)

  # or alternatively, we can use the operator %in% in place 
    #  of multiple OR statements
subdat3 = dat[which(dat$month%in%c("Feb","Mar")), ]
table(subdat3$month)

subdat3 = subset(dat,month%in%c("Feb","Mar"))
table(subdat3$month)

#dplyr approach
subdat3 = dat%>%filter(month%in%c("Feb","Mar"))
table(subdat3$month)


# To select observations based on values of more than one variable
#base packages approach
subdat3 = dat[dat$month%in%c("Feb","Mar") & dat$vessel=="A001", ]
table(subdat3$month,subdat3$vessel)

#dplyr approach
subdat3 = dat%>%filter(month%in%c("Feb","Mar") & vessel=="A001")
table(subdat3$month,subdat3$vessel)

#same outcome..just using ',' instead of '&'
subdat3 = dat%>%filter(month%in%c("Feb","Mar") , vessel=="A001")
table(subdat3$month,subdat3$vessel)


```


<br>

## Student task
* Create a new data frame equal to dat
* For the new data frame, create the variable 'mean.catch' which is the average catch of all records
* Then, remove all records from January and March
and from vessels with less tan 4 crew (tip numcrew>3)
* Finally, keep only the variables 'vessel' and 'mean.catch'

Do it first using base packages

Repeat using dplyr and pipes

<br>

## Solution to student task
```{r}
#base packages solution
dat1=dat
dat1$mean.catch=mean(dat1$catch)
dat1=dat1[!dat1$month%in%c("Jan","Mar") & dat1$numcrew>3, ]
dat1=dat1[,c('vessel', 'mean.catch')]

#dplyr solution
dat2=dat%>%mutate(mean.catch=mean(catch))%>%
  filter(!month%in%c("Jan","Mar") & numcrew>3)%>%
  select(vessel, mean.catch)

dat1
dat2





```


```{r}
#4 Change the ordering of the observations

## In the base packages we can use the function "sort" and "order" 
dat$days
sort(dat$days)

# What if want to sort not just the days column 
#  but the entire data.frame (all columns) based on the value 
#  of the "days" variable. 
#To do this, we use "order" 
head(dat%>%select(-c(cpue1,cpue2)))
dat = dat[order(dat$days), ]
head(dat%>%select(-c(cpue1,cpue2)))
#Notice how the row numbers look all mixed up now!

## sort/order by numcrew and catch
head(dat%>%select(numcrew, catch))
dat = dat[order(dat$numcrew,dat$catch), ]
head(dat%>%select(numcrew, catch))

## How about ordering by a character vector?
dat$month[order(dat$month)]
## Uh, oh it sorts alphabetically!
## If you want to sort by character vectors, 
# you will need to convert them to a factor 
## and specify the order of the levels.
unique(dat$month)
dat$month=factor(dat$month, 
                 levels=c("Jan", "Feb", "Mar")) 
## use levels=month.abb to get all 12 months

## And now lets try that again!
dat$month[order(dat$month)]
dat[order(dat$month), -c(8:9)]


# So, to sort by month
dat = dat[order(dat$month), ]
dat[,-c(8:9)] 

#The "order" function, by default, sorts by ascending order. 
# This means that numeric variables will be sorted from lowest
#   to highest, character variables will be sorted 
#   in alphabetic order, and factors will be sorted by order
#   of their levels. 
# You can also choose to sort by descending order, by using 
# the argument decreasing=TRUE.
head(dat[,-c(8:9)],4)
dat = dat[order(dat$year, decreasing=TRUE), ]
head(dat[,-c(8:9)],4)

#dplyr approach for ordering
head(dat[,-c(8:9)],4)
dat = dat%>%arrange(monthnum,vessel)
head(dat[,-c(8:9)],4)

```


<br>

## Create summary statistics of variables within a given table
* There are many times that we are interested in creating summary statistics from a 
given data set.
* Typically, this set of summary statistics may be required for a 
given grouping of variables. 
* For example, we may want to count the number of fishing 
trips in a year, or the sum of the catch by method of fishing within each year.
* Or we may want to calculate the mean catch rate for each year, or even for each vessel 
within each year. 
* For this purpose, there are a number of functions that we can use to produce summary tables for our data.


```{r}
# 1. The "table" function
# this function counts the number of data (rows in our data frame)  
#  for the given variable (column name).

#Let's count the number of records per year
table(dat$year)

#And how about the number of records per month
table(dat$month)

#And now the number of records per vessel
table(dat$vessel)

# We can do this for multiple variables at a time
# Let's count the number of records by year and month
table(dat$year, dat$month)
# or we can flip the year and month variables
table(dat$month, dat$year)

# What about three variables?
table(dat$year, dat$month, dat$vessel)
# ...a little messy

# And remember that the order of variables makes a 
# difference to the output
table(dat$year, dat$vessel, dat$month)

# My suggestion is that the "table" function is great 
#  for one or even two variables but may be a little
#  confusing for 3 or more variables.


# It is worth noting that the table function can treat
#  NA's, i.e. missing values in, different ways. 
# By default it actually excludes them!
## Lets look at the numcrew variable...
dat$numcrew[1]=NA

table(dat$numcrew)
table(dat$numcrew,useNA = 'always') 


# Note, You can also plot table objects i.e. 
#  the output from the table command using 
#  the generic "plot" function. 
#  A 1-dimensional table (i.e. 1 variable) will plot as 
#  type "h" which are skinny histogram-like vertical lines.
table1 = table(dat$month)
plot(table1)

# 2-dimensional tables (i.e. 2 or more variables) plot as 
# mosaic plots
table2 = table(dat$year, dat$month)
plot(table2, col=2:4)

#2-dimensional tables
table3 = table(dat$year, dat$month, dat$vessel)
plot(table3, col=2:3)

# So the "table" function is great if you want to know how many 
#  data observations for a variable.


# 2. Other summary functions

# Base functions - tapply and aggregate
#  These functions can calculate the sum, or the average, 
#   or various other mathematical quantities of a given 
#  variable for various levels of another variable or variables.
#  Basically you need to tell tapply or aggregate 3 things:
# (1) Our variable of interest, e.g. catch
# (2) Our grouping variable, e.g. by year, or by year and month
# (3) The mathematical function, e.g. sum or average or count or...  


## "tapply" 


# When our data is in a dataframe, this function is 
#  very easy to use.
# Basically "tapply" (and "aggregate" below) are like the
#  pivot table functions in Excel. 
# We just have to tell the function which column/s of the 
#  dataframe to use for steps (1) and (2), and what 
#  function to use in step (3).
# So, to sum up the catch for each year in our data set, we have:
# (1) Our variable of interest is catch so the column is dat$catch
# (2) Our grouping variable is year so the column is dat$year
# (3) the function is sum, which is a built-in function in R.

# Remember the order in this function is:
# (1) VARIABLE, (2) GROUPING VARIABLE, (3) FUNCTION

#try our tapply function to sum up the catch in each year
newdat=subset(dat, !is.na(catch))
tapply(X=newdat$catch, INDEX=newdat$year, FUN=sum) 

# you dont need to write the names for these arguments...
tapply(newdat$catch, newdat$year, sum)


# Now we can extend the "tapply" function to group by multiple variables
# Note that the grouping variable or variables must be written as a list.
# This means we write list(dat$year, ...)
tapply(newdat$catch, list(newdat$year, newdat$month), sum)

#...and now grouping by 3 variables
tapply(newdat$catch, list(newdat$year, newdat$month, newdat$vessel), sum)
#...same as for table function - starts looking messy.


## Lets try our "tapply" on original data when there's NAs
dat$catch[2]=NA

#by year
tapply(dat$catch, list(dat$year), sum)
#so one of the 2015 records is NA, 
# this affects to the entire 2015 records

#fix it
tapply(dat$catch, list(dat$year), sum, na.rm=TRUE)


## by year and month
tapply(dat$catch, list(dat$year, dat$month), sum)
tapply(dat$catch, list(dat$year, dat$month), sum, na.rm=TRUE)


# Sometimes the tapply command starts looking a little verbose
#  with the data.frame name repeated. 
# We can abbreviate this using the "with" function...
with(dat, tapply(catch, list(year, month), sum, na.rm=TRUE))

# This abbreviation via the "with" function can be quite useful 
#  when you wish to subset the main data set.
with(subset(dat, year>2014), 
     tapply(catch, list(year, month), sum, na.rm=TRUE))


# You can use any function within the tapply function that 
#  takes one input and returns a single output. For example:
# sum, mean, min, max, length, sd and so on. 
with(dat, tapply(cpue1, list(year, month), mean, na.rm=TRUE))
with(dat, tapply(cpue1, list(year, month), sd, na.rm=TRUE))


# How about the number of records i.e. function is "length" 
# (length function= 'count' function in excel)
tapply(dat$cpue, list(dat$year), length, na.rm=TRUE)
# Oops, the length function doesnt accept this na.rm=TRUE argument. 
tapply(dat$cpue, list(dat$year), length)

# But without removing NAs, it counts the extra row as a data point??
# So how would we calculate the number of records per year, 
# but omitting row 2 i.e. the catch=NA?? There are a number of ways:
# (1) you could subset the data: 
with(subset(dat, !is.na(cpue1)), tapply(cpue1, 
                                        list(year, month), length))
# (2) you could write your revised "length" function to count 
#    non-NA observations
CalcLengthRevised=function(x)
{
  result=length(x[!is.na(x)])
  return(result)
}
tapply(dat$cpue1, list(dat$year), CalcLengthRevised)
#so here we wrote our own function for use in tapply

#other useful user-built function:
CalcStdError=function(x)
{
  stderror=sd(x)/sqrt(length(x))
  return(stderror)
}
with(newdat, tapply(cpue1, list(year), CalcStdError))


## Now, lets have a look at the output of tapply
table1=tapply(newdat$catch, list(newdat$year), sum)
table1
## If we look at the structure of the output object, 
# its a bit confusing.
str(table1)
## Lets look at a tapply output with 2 grouping variables
table2=tapply(newdat$catch, list(newdat$year, newdat$month), sum)
table2
## The structure is still a bit confusing.
str(table2)
## and so on for 3 grouping variables
table3=tapply(newdat$catch, list(newdat$year, newdat$month,
                                 newdat$vessel), sum)
table3

# This type of object is called an array, with the levels
# of the grouping variables (i.e. year, month, vessel...) 
# being the dimension names.


#  "aggregate" 

# The "aggregate" function essentially performs the same 
#  function as the "tapply" function but returns the result
#  in a different format which is often a lot easier to work
#  with in our analyses. 
# The output of the aggregate function is another data.frame
# As for the tapply function, we need to define
# (1) the variable of interest
# (2) the grouping variable/s 
# (3) the function to apply to the variable of interest
#     for each combination of the grouping variables.

#tapply version
with(newdat,tapply(catch, list(year), sum))

#aggregate version
with(newdat,aggregate(catch, list(year), sum))

#...but better to give names to new columns
with(newdat,aggregate(data.frame(catch=catch), list(year=year), sum))

# there is also a 'formula' version of aggregate
aggregate(catch~year, newdat, sum)


#As for tapply, you can write your own function if needed
CalcStdError
aggregate(cpue1~year, newdat, CalcStdError) 


# The aggregate function also has the ability to calculate 
#  summary statistics for multiple variables.
# For example, we could calculate the total catch per and
#  total number of fishing days per year by 
aggregate(cbind(catch, days)~year, newdat, sum)

# As for the tapply function, we can group over multiple variables
# Lets group over year and month
aggregate(catch~year+month, newdat, sum)
# Or year and vessel
aggregate(catch~year+vessel, newdat, sum)



# Let's do some calculations that are actually meaningful..

# Calculate the total catch per year, 
#  and the average catch rate per year
aggregate(catch~year+vessel, newdat, sum)
aggregate(cpue1~year+vessel, newdat, mean)
#...it would be nice to combine these into one output.
# we can do this with "merge".


# The "merge" function
#  First calculate the total catch per year via aggregate.
agg1=aggregate(catch~year+vessel, newdat, sum)
agg1
#  Now calculate the average catch rate per year via aggregate.
agg2=aggregate(cpue1~year+vessel, newdat, mean)
agg2

#  Combine these 2 data sets (agg1a and agg1b) as they have 
#    the year and vessel columns in common. 
aggcomb1=merge(agg1, agg2, by=c("year", "vessel"))
aggcomb1

# Lets try another example:
# Say we would like to calculate the average catch rate per year,
#  and in addition, calculate the confidence intervals
agg3=aggregate(cpue1~year+vessel, newdat, mean)
agg3
agg4=aggregate(cpue1~year+vessel, newdat, CalcStdError)
agg4

# As before, we would like to combine these 2 data sets 
# Problem: the 3rd column in each of the data 
#          sets is called "cpue". 
aggcomb2=merge(agg3, agg4, by=c("year", "vessel"))
aggcomb2

#Let's fix it
agg4
names(agg4)[which(names(agg4)=="cpue1")]="cpue.se"

# Now merge 
aggcomb2 = merge(agg3, agg4, by=c("year", "vessel"))
aggcomb2


# And now we can plot the cpue by year and vessel with 
# confidence intervals
#  First lets calculate the lower and upper confidence limits.
aggcomb2$lowCL = aggcomb2$cpue1 - 1.96 * aggcomb2$cpue.se
aggcomb2$uppCL = aggcomb2$cpue1 + 1.96 * aggcomb2$cpue.se
aggcomb2

#  And now to plot the cpue by year with confidence intervals
plot(aggcomb2$year, aggcomb2$cpue1, "n", ylim=c(0, 40), 
     axes=FALSE, las=1, xlab="Year", ylab="CPUE")
for (ivessel in unique(aggcomb2$vessel))
{
  subdat=subset(aggcomb2, vessel==ivessel)
  ivesselnum=which(unique(aggcomb2$vessel)==ivessel)
  lines(subdat$year, subdat$cpue1, "o", pch=16, lty=2,
        col=ivesselnum+1)
  arrows(subdat$year, subdat$lowCL, subdat$year,
         subdat$uppCL,code=3, angle=90, length=0.02,
         col=ivesselnum+1)
}
axis(1, at=2014:2016)
axis(2, at=seq(0, 40, 10), las=2)
legend("topright", legend=unique(aggcomb2$vessel), 
       pch=16, lty=2, col=2:3, 
       bty="n", cex=0.8)


```

<br>

## Student task
* Create a new data frame equal to dat
* Calculate mean and SE of the variables 'days' and 'catch' by 'year'
* In one page, Plot mean days (and 95% CI) by year and mean catch (and 95% CI) by year 


<br>

## Solution to student task
```{r}
# Create a new data frame equal to dat
dat3=dat

# Calculate mean and SE of the variables 'days' and 'catch' by 'year'
agg3=aggregate(cbind(days,catch)~year, dat3, mean)
agg4=aggregate(cbind(days,catch)~year, dat3, CalcStdError)

names(agg4)[which(names(agg4)%in%c("days","catch"))]=c("days.se","catch.se")
aggcomb2 = merge(agg3, agg4, by="year")

aggcomb2$days.lowCL = aggcomb2$days - 1.96 * aggcomb2$days.se
aggcomb2$days.uppCL = aggcomb2$days + 1.96 * aggcomb2$days.se

aggcomb2$catch.lowCL = aggcomb2$catch - 1.96 * aggcomb2$catch.se
aggcomb2$catch.uppCL = aggcomb2$catch + 1.96 * aggcomb2$catch.se

# In one page, Plot mean days (and 95% CI) by year 
#  and mean catch (and 95% CI) by year
par(mfcol=c(2,1),mar=c(4,4,2,2))
with(aggcomb2,plot(year,days,ylim=c(0,max(days.uppCL)),pch=19,
     ylab="Days",xlab="Year"))
with(aggcomb2,arrows(year, days.lowCL, year,days.uppCL,code=3,
                     angle=90, length=0.02))

with(aggcomb2,plot(year,catch,ylim=c(0,max(catch.uppCL)),pch=19,
     ylab="Catch",xlab="Year"))
with(aggcomb2,arrows(year, catch.lowCL, year,catch.uppCL,code=3,
                     angle=90, length=0.02))






```
<br><br>



DEJE ACA


<br>

## Student task
* Create a new data frame equal to dat
* Calculate mean and SE of the variables 'days' and 'catch' by 'year'
* In one page, Plot mean days (and 95% CI) by year and mean catch (and 95% CI) by year 

this time...Use dplyr 
<br>




##=============================================================
## Summarising in the "dplyr" package - group_by and summarise
##=============================================================
## We've seen how to produce summary statistics using the tapply and aggregate functions
## available in the base package. Now lets see how to do the same thing using the 
## functions of the dplyr package. The 2 new function we will need are "summarise" and
## group_by.

## Lets consider our data set with catch=NA removed
newdat

## And lets try to repeat the aggregate command we used previously to calculate the 
## sum of the catches and vessel
agg1=aggregate(catch~year+vessel, newdat, sum)
agg1

## So, the 2 commands we need to use are summarise and group_by,
## First we group the data, then we calculate the summary statsitics
group.data=group_by(newdat, year, vessel)
summarise(group.data, catch = mean(catch))
## The output of summarise is a slightly different format than aggregate. Its called
## a tibble and is somewhat like a data.frame. In fact, it can easily be converted to
## a data.frame if you wish using "data.frame" or "as.data.frame".
data.frame(summarise(group.data, catch = mean(catch)))
as.data.frame(summarise(group.data, catch = mean(catch)))

## Now, remember that piping operator we saw previously when using the "select" and 
## "filter" functions of dplyr:
subset7 = dat %>%
  filter(month%in%c("Feb","Mar")) %>%
  select(c(year, month, vessel, catch))
subset7
## Well, we can use the piping operator now with the group_by and summarise functions
## in dplyr:
summarydat1 = newdat %>%
  group_by(year, vessel) %>%
  summarise(catch=sum(catch)) %>%
  as.data.frame
summarydat1
## This looks like exactly like the output of the aggregate command above.
agg1

## Just as in tapply and aggregate we can use a range of functions within the summarise
## command like sum, mean, min, max etc. However, summarise actually allows different
## functions to be applied to different variables. For example, we can calculate the
## mean of the catch rates, but we can also calculate the sum of the catches. 
summarydat2 = newdat %>%
  group_by(year, vessel) %>%
  summarise(catch=sum(catch), cpue=mean(cpue)) %>%
  as.data.frame
summarydat2
## Pretty efficient! - Lets compare this to our aggregate output, remembering that when
## using aggregate we had to calculate 2 separate aggregate functions then combine via 
## the merge function!
aggcomb1
## The same!

## Now lets add the calculation of the standard errors of the cpues and then their
## confidence limits. Note that in this calculation I have renamed the average cpue to
## cpue.mean. This needs to be done as I want to undertake another calculation of the
## original cpue variable (i.e. the standard error) and the function will get confused
## with the original cpue variable and the new average value if we use the same name.
## Its probably good practice to use all new names in the summary function from those 
## in the original table.
summarydat3 = newdat %>%
  group_by(year, vessel) %>%
  summarise(catch=sum(catch), cpue.mean=mean(cpue), cpue.se=CalcStdError(cpue)) %>%
  mutate(lowCL = cpue.mean-1.96*cpue.se, uppCL = cpue.mean+1.96*cpue.se) %>%
  as.data.frame
summarydat3
## compare with aggregate output
aggcomb4
## Excellent. They match exactly!!

## Just one final point - we could also integrate the filter function within our piping
## code to use the original data and subset for non-NA values. In addition, rather than
## writing our own function to compute the standard error we could simply calculate this
## within our piping code also. 
summarydat4 = dat %>%
  filter(!is.na(catch)) %>%
  group_by(year, vessel) %>%
  summarise(catch=sum(catch), 
            cpue.mean=mean(cpue), 
            cpue.sd=sd(cpue), 
            n=n()) %>%
  mutate(cpue.se=cpue.sd/sqrt(n), 
         lowCL=cpue.mean-1.96*cpue.se, 
         uppCL=cpue.mean+1.96*cpue.se) %>%
  as.data.frame
summarydat4
## compare with aggregate output
aggcomb4
## Excellent. They still match exactly!!

## We could further add to our piping code to use the select function to remove the
## additonal columns of cpue.sd and n if we didnt want to retain them in the final 
## data set.

## And quickly heres an example of the plotting available in the tidyverse plotting
## package called "ggplot2"
library(ggplot2)

ggplot(summarydat4, aes(year, cpue.mean, colour=vessel)) + 
  geom_point(pch=16) +
  geom_line(lty=2) +
  geom_errorbar(width=.1, aes(ymin=lowCL, ymax=uppCL)) +
  labs(x="Year",y= "CPUE") + 
  scale_y_continuous(breaks=seq(0,40,10), limits = c(0, 40)) +
  scale_x_continuous(breaks=2014:2016)

##=====================================================================================
## NOW IT'S YOUR TURN!!!!
##=====================================================================================
## Try importing the other 'fake' fisheries catch and effort data set called
# "fisheries catch and effort data v2.csv"

## (1) Create a summary table of total catches by year and month using the tapply 
## function. Then recalculate using the aggregate function.
## Which version do you prefer?? Why??

## (2) Create a summary table of average catch rate by year and vessel including their 
## 95% confidence intervals (assuming a normal distribution). You can choose to use the 
## aggregate function or the dplyr functions using piping code to do this.

## (3) Plot the catch rates from (2) with their 95% confidence intervals.

##=====================================================================================
## END OF CODE
##=====================================================================================


##==========================================================================
## SECTION 1: DATA PREPARATION
##==========================================================================
## Read in data from csv file or text file.
# list files in wd
dir()

# read in csv data
dat=read.csv("CAES_Extraction_Block_95020_2010_2017.csv")
head (dat)
head(dat,2)
dim(dat)
names(dat) # for a data frame, names(dat) is the same as colnames(dat)

# convert upper case characters to lowercase (header line)
# upper=FALSE is the default option so doesn't necessarily need to be there but there for completion 
names(dat) = casefold(names(dat), upper=FALSE) 

names(dat)

# convert rest of data frame to lower case
dat = data.frame(lapply(dat, function(v) {
  if(is.character(v))return(tolower(v))
  else return(v)
}))

head(dat)

## Rename columns if desired.


## Remove columns/variables if not required -  maybe there are some 
## additional variables included in the data set that simply not required, 
## or maybe you're not sure what some of the variables are - if so, you   
## might need to check if you need them!

## have a look at the variables
## use summary functions such as table, unique and summary to look at each variable

str(dat)

head(dat)
names(dat)


unique(dat$"nilr_hi")
table(dat$"nilr_hi") # table function by default omits any NA's
table(dat$"nilr_hi", useNA= always) # to keep any NA's in if you want them


## subset using select function for columns that are required (remove those that you dont need)
dat=subset(dat, select=c(year, month, vessel, fdays, crew, port, method, blockx, bdays, hours, pots, shots, netlen, species, sname, 
                         conditn,livewt, mslow, mshigh))
head(dat)
dim(dat)
str(dat)

## Have an initial look at data to check remaining variables for errors, 
## outliers and missing values (are they NA's or errors).
## Conduct some exploratory data summaries of all variables that will be
## considered in the analyis using functions such as "table" and "unique" to 
## basically try to understand the format of the data.

unique(dat$year)
table(dat$year)

unique(dat$month)
table(dat$month)

table(dat$year, dat$month) # or can do a two way table if want to see in what year and months there is data

table(dat$port) 

table(dat$vessel, dat$port) # good to see whether for eg. a particular vessel is associated with a particular port

unique(dat$blockx) # single block fishery
table(dat$blockx) # block 95020, with 3508 observations

table(dat$vessel)
# note there is m039 and m039a. Are they the same vessel/replacement vessel etc...? ie. can they be joined together

table(dat$year, dat$vessel)

## notice m039 and m039a never fishing concurrently- should be considered as the same vessel
## combine m039a with m039
dat$vessel[which(dat$vessel=="m039a")] = "m039"
unique(dat$vessel) # to make sure that they have combined

unique(dat$method)
table(dat$method)

# pt and ct are the same so can be joined also (to ct as that is obviously the dominant method)
dat$method[which(dat$method=="pt")]= "ct"
table(dat$method) # to make sure pt has been reassingned to ct

table(dat$fdays)
table(dat$bdays) # sum of number of block days doesn't always equal the sum of fishing days

table(dat$crew)

table(dat$hours)

table(dat$pots)

table(dat$method, dat$pots)

table(dat$method, dat$shots)

table(dat$method, dat$netlen)

unique(dat$species)

unique(dat$sname)

unique(dat$conditn)

## Do we need to remove data from incomplete years/months? Might do that at
## this stage or maybe leave for later.



##==========================================================================
## SECTION 2: DATA MANAGEMENT - BY UNIQUE FISHING EVENT
##==========================================================================
## With catch and effort data sets, it is often useful to get your data into
## a form where each line represents a unique fishing event. And typically,
## this is not how the data is first extracted!!!!! For example, in a CAES 
## extraction each species caught during a "unique fishing event" (which is 
## a fishing session in a given year and month for an individual vessel in a 
## particular block using a particular gear method and configiration) is
## recorded on a separate line. So the effort variables like days fished, 
## hours fished, number of pots or shots is repeated on each line. By 
## creating a data set where each line represents a unique fishing event, it
## is often a lot easier to then use this new data set to calculate  
## summaries of effort and catch rate.
## So, first we are going to get our data in this "unique fishing event" form
## and then we can move on to actually calculating our summary tables as 
## outlined in Section 3. 

## In order to do so we must consider:
## - what variables help us to distinguish each individual fishing event, 
## - what variables we will need to keep in our data set to make sure we 
##   achieve our desired objective 
##    - fishing method/appropriate effort measures for each fishing event 
##    - catch of single/multiple/all species for each event
##    - spatial and temporal information for each event. 
##
## Questions: 
## - What species are we interested in - single, few or many?
## - What fishing methods are we interested in - maybe multiple methods for
##   total catch but only the main method for catch rates???
## - What effort variables are we interested in?
##   It is worth noting here that there are typically more than one effort
##   measure that CAN and SHOULD be considered. This helps us to get a more 
##   complete picture, and often forces us to provide justifications for not 
##   using one measure over another?
## - What other effort variables are recorded but perhaps not usable at this 
##   stage as they require further validation or there is some reason why 
##   their consideration is simply inappropriate?

names(dat)






##==========================================================================
## SECTION 3: MAKE SUMMARY TABLES
##==========================================================================
## What summaries are we interested in, and in what format? i.e. do we need
## the tables themselves or do we need them so that we can make a plot?
## Remember back to our overarching OBJECTIVE - summary tables and plots of
## catch, effort and catch rate.
## So what exactly do we want?
## - Catch by year for target and/or key species
## - Total catch of all species by year 
## - Annual catch by fishing method
## - Annual catch by vessel
## - Effort by year (what is our measure of effort?? multiple measures??)
## - Nominal catch rate by year
## - Annual mean catch rate 
## - Possibly also require data compiled for future catch rate 
##   standardisation analysis either by yourself or by someone else i.e. SADA
##   (Please note that we won't be covering CPUE standardisation in this  
##   session as that's a quite a task in its own right.)
## - Anything else???



##==========================================================================
## SECTION 3: MAKE SUMMARY PLOTS
##==========================================================================
## Using tables above, we will create the plots that we desire for our 
## overarching OBJECTIVE - summary tables and plots of catch, effort and 
## catch rate.
## So what exactly do we want - maybe what we mentioned above?
## - Catch by year for target and/or key species
## - Total catch of all species by year 
## - Annual catch by fishing method
## - Annual catch by vessel
## - Effort by year (what is our measure of effort?? multiple measures??)
## - Nominal catch rate by year
## - Annual mean catch rate 
## - Anything else???
## What type of plot - line plot, bar chart?
## Do we need to, and are we able to, include confidence intervals?
## How can we save out plots for future use, and in what format do we wish
## to save them - jpeg, tiff, eps, png etc.






tidyverse cheat sheet
https://rstudio.com/resources/cheatsheets/

