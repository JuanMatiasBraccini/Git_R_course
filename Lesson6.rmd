---
title: "Lesson 6. Plotting and Mapping"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "C:/Matias/Cursos/2019_Mexico/htmls") })

output: 
  html_document:
    code_folding: show
    highlight: haddock
    keep_md: yes
    theme: united
---

<style type="text/css">
h1.title {
  font-size: 30px;
    color: Maroon;
  text-align: center;
          }
h3.subtitle {
  font-size: 22px;
    color: Maroon;
  text-align: center;
            }
h4.author { 
    font-size: 24px;
      color: FireBrick;
  text-align: center;
          }
h4.date { 
  font-size: 18px;
  text-align: center;
        }
h1{
  font-size: 22px;
  color: DarkBlue;
  }
h2{
  font-size: 20px;
  color: Blue;
  }
h3{
  font-size: 18px;
  color: SteelBlue;
  }
body{
    font-family: Helvetica;
    font-size: 14pt;
    }
code.r{
  font-size: 16pt;
      }
pre {
  font-size: 16pt;
}
</style>


```{r globaloptions, include=FALSE}
knitr::opts_chunk$set(fig.width = 6,fig.height = 6,
                        echo = TRUE, warning=FALSE,message=FALSE)
```

# Lesson goals
We're going to expand on doing plots and maps.



#full list of packages necessary for this series of tutorials can be installed with:
# install.packages(c("cowplot", "googleway", "ggplot2", "ggrepel", "maps","rgeos","grid",
#                     "ggspatial", "libwgeom", "sf", "rnaturalearth", "rnaturalearthdata",
#                     "rsvg","magick")


#-----#Base Plotting--------------------
# MSCI 698 Statistical and Graphical Analysis in R    Janos Hoenig, fall 2008
#
# Plotting a function: some advanced techniques

# Suppose we are interested in the function defined in polar coordincates by
# r = 4(1-sin(theta)). What does this function look like, when it is graphed
# over the range of theta from -1.4 pi to 0.7 pi?

theta <- seq(-1.4*pi,.7*pi,.01)   # set up a vector of theta values over which
# the function will be evaluated

r <- 4*(1-sin(theta))             # compute the corresponding values of r

x <- r*cos(theta)                 # convert to Cartesian (x-y) coordinates
y <- r*sin(theta)
xrange <- range(x)                # dtermine the range of the x and y values
yrange <- range(y)

require(graphics)             # some systems require you to do this; most don't

pie(rep(1,12),col=1:12)   # Note that the default palette has just 8 colors.
# NOTE: to make a pie chart, you specify a vector of relative areas of the
# pie slices; optionally, you can specify the corresponding colors a/o labels

# Color Wheels: let's see what the rainbow colors are when we specify n colors
pie(rep(1,6),col=rainbow(6))
pie(rep(1,12),col=rainbow(12))
pie(rep(1,24), col=rainbow(24))

palette(rainbow(24)) # decide to use the rainbow palette with 24 shades of color

par(bty="n",xaxt="n",yaxt="n")   # no box, no x-axis, no y axis
plot(c(0,.2),c(-1,-1),typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="")  
# you have to plot something before you can add a colored rectangle or polygon

par(xpd=NA)      # xpd determines how much of the page is plotted on.
# xpd can be: FALSE, TRUE or NA (see below)

rect(-10, -14, 7, 4.5,col=19)   # draw a rectangle with lower left corner at
# (x,y) = (-10,-14) and upper right corner at
# (x,y) = (7,4.5) and fill it with color 19

rect(-7, -9, 5.3, 2.5,col=20)

par(new=T)          # we need the par() statement because the next command is a
# high level plotting function (as opposed to rect, abline,
# text, etc. that are low-level plotting commands) - without
# the par() statement a high level plotting command will 
# paint over the previous plot
plot(.8*x,.8*y,typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="",lwd=1.7,col=7)
# We have plotted the function. (I multiplied the x and y values by .8 so they'd
# fit on the page better.) We can also plot the figure as if it were a polygon
# and fill it with a color, as in the next line

polygon(.8*x,.8*y,xpd=NA,col=21)   # polygon is a low-level plotting function.

polygon(.64*x,.64*y-.7,col=22)
polygon(.64*.8*x,.64*.8*y-1.2,col=23)
text(0,-7.5,col=13,expression(paste("I'm thinking r = 4(1-sin",theta,")")),
     cex=2.0)

# now add two small hearts on the left
par(new=T)
plot(.1*x-4.7,.1*y+1,typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="",lwd=1.7,
     col=13)
par(new=T)
plot(.1*x-4.7,.1*y-6,typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="",lwd=1.7,
     col=13)


###########################
#
# Let's pick more subtle colors

# Color Wheels
pie(rep(1,6),col=cm.colors(6))
pie(rep(1,12),col=cm.colors(12))
pie(rep(1,24), col=cm.colors(24))
mtext("the cm.colors(24) palette")

palette(cm.colors(24))    # decide to use the cm palette
par(bty="n",xaxt="n",yaxt="n")   # no box, no x-axis, no y axis
plot(c(0,.2),c(-1,-1),typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="")  # have to plot 
# something before you can color a rectangle
par(new=T,xpd=NA)      # xpd determines how much of the page is plotted on
rect(-10, -14, 7, 4.5,col=1)
rect(-7, -9, 5.3, 2.5,col=5)         # I don't like the black border on the box
rect(-7,-9,5.3,2.5,col=4,border=NA)  # get rid of the border

polygon(.8*x,.8*y,xpd=NA,col=19, border=NA)

polygon(.64*x,.64*y-.7,col=21, border=NA)

polygon(.64*.8*x,.64*.8*y-1.2,col=23, border=NA)
text(0,-7.5,cex=2.3,col=24,expression(paste("I'm thinking r = 4(1-sin",theta,")")))

# now add two small hearts on the left
par(new=T)
plot(.1*x-4.7,.1*y+1,typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="",lwd=1.7,col=24)
par(new=T)
plot(.1*x-4.7,.1*y-6,typ="l",xlim=xrange,ylim=yrange,xlab="",ylab="",lwd=1.7,col=24)

############################################################################

# Some loose ends.

############################################################################

# the par( ) parameter xpd:
#                 FALSE   plot is clipped to fit in the plot region (within 
#                            the figure region)
#                 TRUE    plot is clipped to fit in the figure region
#                 NA      plot can cover the entire page
# see demo below
x <- c(1:9,8:1)
y <- c(1,2*(5:3),2,-1,17,9,8,2:9)
par(mfcol=c(3,1))
for(xpd in c(FALSE,TRUE,NA)) {
  plot(1:10, main = paste("xpd =", xpd))
  box("figure", col = "pink", lwd=3)
  polygon(x,y, xpd=xpd, col="orange", lty=2, lwd=2, border="red")
}

##############################################################################
#
# Here is a little program to show you what some color pallettes look like.
# Don't worry about trying to understand the program - just look at the output
# to see some of your options

demo.pal <-
  function(n, border = if (n<32) "light gray" else NA,
           main = paste("color palettes;  n=",n),
           ch.col = c("rainbow(n, start=.7, end=.1)", "heat.colors(n)",
                      "terrain.colors(n)", "topo.colors(n)",
                      "cm.colors(n)"))
  {
    nt <- length(ch.col)
    i <- 1:n; j <- n / nt; d <- j/6; dy <- 2*d
    plot(i,i+d, type="n", yaxt="n", ylab="", main=main)
    for (k in 1:nt) {
      rect(i-.5, (k-1)*j+ dy, i+.4, k*j,
           col = eval(parse(text=ch.col[k])), border = border)
      text(2*j,  k * j +dy/4, ch.col[k])
    }
  }
n <- if(.Device == "postscript") 64 else 16
# Since for screen, larger n may give color allocation problem
demo.pal(n)
###############################################################################

# pie charts:  NOTE what the R help page says about pie charts!!!

# examples taken from the bottom of the help page for the pie( ) function

pie.sales <- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)
names(pie.sales) <- c("Blueberry", "Cherry",
                      "Apple", "Boston Cream", "Other", "Vanilla Cream")
pie(pie.sales) # default colours
pie(pie.sales,
    col = c("purple", "violetred1", "green3", "cornsilk", "cyan", "white"))
pie(pie.sales, col = gray(seq(0.4,1.0,length=6)))
pie(pie.sales, density = 10, angle = 15 + 10 * 1:6)
pie(pie.sales, clockwise=TRUE, main="pie(*, clockwise=TRUE)")
segments(0,0, 0,1, col= "red", lwd = 2)
text(0,1, "init.angle = 90", col= "red")

n <- 200
pie(rep(1,n), labels="", col=rainbow(n), border=NA,
    main = "pie(*, labels=\"\", col=rainbow(n), border=NA,..")

################################################################################
#
#  SUMMARY OF COMMANDS
#
# arguements to par()
#     xpd                     specify limits to plotting:
#                                FALSE - restrict plotting to the plot area
#                                TRUE - restrict plotting to the figure area
#                                NA means plot anywhere on the page
#     bty="n"                 box type, e.g., "n" = none
#     xaxt="n",yaxt="n"       x-axis and y-axis types, e.g., "n" = none
#
# palette(name(number))       set palette equal to name, with number of colors
#                                equal to number
#
# high level plotting commands
#     pie(x,labels,border)    create a pie chart with areas of slices given by x 
#
# low level plotting commands
#     rect(x1,y1,x2,y2)       draws a rectangle where you specify (x1,y1 give 
#                                  the lower left corner and x2,y2 give the 
#                                  upper right corner
#     polygon(x,y,color)      draws a polygon by connecting in order a series of
#                                 (x,y) coordinates and, optionally, cross
#                                 hatches or colors the interior
#     box()                   draws a box around the plotting region (with
#                             rect you can do the same thing but you need to
#                                specify where you want the box
#
################################################################################


#Graphying surfaces (3d)
# MS698 - Statistical and Graphical Analysis in R                     Fall, 2010 

# Instructor:	Janos (John) M. Hoenig 
# Contact:	hoenig@vims.edu  
#           office: x7125; home: 757 564 9766; cell: 804 815 2912
#
# This script demonstrates how to make 3-D (three dimensional) graphs using
# the contour( ), persp( ) and image( ) functions.

# There are some other graphical functions of interest in the lattice and MASS
# packages. Here's a table summarizing availability of functions in the
# graphics package (which comes with R, you don't have to load it) and the
# MASS & lattice packages (which you have to load, e.g., using library(MASS) ).

# METHOD                  IN (graphics)         IN (package)
#
# 3D scatterplot                                cloud (lattice)
# matrix of scatterplots  pairs                 splom (lattice)
# bivariate density surf. persp                 wireframe (lattice)
# contour plot            contour, image       contourplot (lattice)
#                         contourLines          contour (MASS)
#                         filled.contour        levelplot (lattice)
# parallel coord. plot                          parallel (lattice)
#                                               paracoord (MASS)
# star plot               stars
# segment plot            stars
# interactive 3D graphics                       (rggobi), (rgl)

# If you don't like the output from one function, you can try a similar 
# function in another package. Note that star plots and segment plots are
# demonstrated in the superplot.r files in the reference documents & scripts
# folder, and interactive 3D plots are illustrated in the 
# fun with scatterplots.r script in the plotting folder (i.e., the folder where
# this script resides.

################################################################################
# Let's look at the surface of the log likelihood of the index-removal estimator 
# of catchability (q) and population size (N) over some range of q and N. That
# is, we'll want our graph to have population size on the x-axis, catchability
# q on the y-axis, and height (z-axis value) equal to the value of the log
# likelihood function.

# We set up a vector of q values and a vector of N values and then compute a
# value of the function for each combination of q and N; we store these function
# values in a matrix.

maxlen<-30					      # this value determines the resolution of the graph
#(output matrix will be maxlen X maxlen)

# Generate the output matrix.  For the moment it will be a square matrix 30x30
# filled with NAs                             
answer<-matrix(ncol=maxlen,nrow=maxlen)		 
answer

# Create a vector N with 30 values, equally spaced between 11 and 100

N <-seq(11,100,len=maxlen) # min N is 11 to avoid warnings
N
# Create a vector q with 30 values, equaly spaced between 0.1 and 2 
# range of q's of 0.1 to 2 is reasonable 
# Using 0 is ok, but we end up with Inf's at edges

q <- seq(0.1,2,len=maxlen)	 
q

c1 <- 40  # catch rate before the fishing period
c2 <- 30  # catch rate after the fishing period
R <- 10   # Number removed during the fishing period

# Calculation of the log likelihood	
# we enter these values as i,j elements of our 30*30 answer matrix														
for (i in 1:maxlen){							# i is for q's and j is for N's
  for (j in 1:maxlen){
    answer[i,j] <- c1*log(q[i]) - c1*log(N[j])- q[i]*N[j] + c2*log(q[i]) +
      c2*log(N[j]-R) - q[i]*(N[j]-R)  # answer is just the value of the loglike.
  }
}

answer[1:5,1:5]

# Ooooof! There must be a shorter way. There is.
expand.grid(q=q,N=N)  # create a matrix with all combinations of q and N
conditions = expand.grid(q=q,N=N)

answer2 <- c1*log(conditions[,1]) - c1*log(conditions[,2])- 
  conditions[,2]*conditions[,1] + c2*log(conditions[,1]) + 
  c2*log(conditions[,2]-R) - q*(conditions[,2]-R) 
answer2  # we get a vector with the 900 calculated log-likelihoods

answer.alt <-matrix(answer2,ncol=maxlen,nrow=maxlen) # reformat the likelihood
# values into a matrix. NOTE: expand.grid arranged the q and N values in
# 2 columns with the q's in column 1 varying the fastest. (i.e., you get
# all 30 values of q with the first value of N, then all 30 values of q with
# the second value of N, etc.		 
answer.alt[1:5,1:5]   # compare the 2 sets of output. They're identical.
answer[1:5,1:5] 

################################################################################
# Contour plot

# the format for contour is contour(x values, y values, z values, number of
# contour lines, ...)
contour(N ,q,answer,nlevel=8,xlab="N",ylab="q" )
contour(seq(11,100,len=maxlen) ,seq(0.1,2,len=maxlen),answer,nlevel=8,xlab="N",ylab="q" )
# The above line does the same thing as the previous line. It just uses the
# seq( ) function to create the values of q and N instead of feeding in a 
# vector of values of q and of N.

contour(seq(10,100,len=maxlen) ,seq(0,2,len=maxlen),answer,
        levels=c(0,-50,-100,-150,-175,-179,-179.5),xlab="N",ylab="q" )
# In the above use of contour, we specify a vector of values for the contour
# lines.

################################################################################
# Perspective plot
# theta and phi are angles defining the viewing direction. 
# theta gives the azimuthal direction and phi the colatitude. 
# r is the distance of the eyepoint from the centre of the plotting box. 
# d is a value which can be used to vary the strength of the perspective 
# transformation. Values of d greater than 1 will lessen the perspective effect 
# and values less than 1 will exaggerate it. 
# expand is an expansion factor applied to the z coordinates. 
# Often used with 0 < expand < 1 to shrink the plotting box in the z direction. 
# ltheta, lphi: if finite values are specified for ltheta and lphi, 
# the surface is shaded as though it was being illuminated from the direction 
# specified by azimuth ltheta and colatitude lphi. 


# The function persp() draws perspective plots of surfaces over the x?y plane

persp(N,q,answer,xlab="N",ylab="q",theta=30,phi=30,expand=0.8,col="pink")
persp(N,q,answer,xlab="N",ylab="q",theta=30,phi=30,expand=0.8,col="pink",
      ltheta=80,shade=0.4,r=6,d=0.5,ticktype="detailed",nticks=10)

################################################################################      
# The function image() creates a grid of colored or gray-scale rectangles with 
# colors corresponding to the values in z.      

image(N,q,answer,xlab="N",ylab="q",col=terrain.colors(100))
box()					
title(main="answer,x=c(15,30),y=c(1.5,1.8),nint=24",font=3)

# We can superimpose a contour plot on the image

image(N,q,answer,xlab="N",ylab="q")					#using the default colors 
contour(seq(10,100,len=maxlen) ,seq(0,2,len=maxlen),answer,
        levels=c(0,-50,-100,-150,-175,-179,-179.5),xlab="N",ylab="q",add=T,col="blue")
# NOTE: I used add=T to add the contour plot to the image plot
title(main="answer,x=c(15,30),y=c(1.5,1.8),nint=24")

#Expressions
# Here we will use the paste() and expression() functions to print text and
# equations that incorporate special symbols and mathematical notation.

?expression          # the help page is highly unreadable!

# expression() creates an expression that can be printed. It does it by
# translating code for equations and special symbols into plotting instructions
# and pasting those translated equations together with any character strings
# you specify.

# try executing these commands

plot(0,0,col=0,xlim=c(0,20),ylim=c(0,20))  # set up any plot so we can
# annotate it
text(10,20,paste("likelihood = ",pi^3*(1-pi)^7),cex=1.5)   
text(10,17,paste("likelihood = ","pi^3*(1-pi)^7"),cex=1.5)
text(10,14,expression(paste("likelihood = ",pi^3*(1-pi)^7)),cex=1.5)

text(10,10,expression(paste("area = ",pi * r^2)))

text(10,7,expression(paste("f(x) = ",1/sqrt(2*pi * sigma)*exp(- 1/(2*sigma^2)*(x - mu)^2))))
text(10,5,expression(paste("f(x) = ",1/sqrt(2*pi * sigma)*e^- 1/(2*sigma^2)*(x - mu)^2)))
text(10,3,expression(paste("f(x) = ",1/sqrt(2*pi * sigma)*exp(- (x - mu)^2/(2*sigma^2)))))

demo(plotmath)    # this is the instruction manual for typsetting equations

##Margins
#  QMS short course in R                         February, 2011
#  instructor: John M. Hoenig, PhD
#  email: hoenig@vims.edu

# A script to illustrate plot margins and outer margins

# There are two kinds of margins in a plot,
#    plot margins - where you put your axis labels, for example
#    outer margins - where you can put text, especially when you have several
#                    plots on a page. The DEFAULT is to have outer margins of
#                    size 0

# create some sample data to plot:
x1 = 2:5
y1 = c(8,5,4,1)
x2 = 2:5
y2 = c(2,3,5,7.7)

par(oma=c(4,4,4,4),mar=c(4,4,4,4))  # set the outer (figure) margin & the
# inner (plot) margin
plot(x1,y1,typ="l")              # make a regular kind of plot
box(which="plot",lty=1,col=2)       # put a red box around the plot margin
box(which="figure",lty=2,col=3)     # put a green box around the figure margin
mtext("plot margin 1",side=1,line=2,col=2)  # add some text in the inner margin
# of side 1
mtext("outer (figure) margin 1",side=1,line=2,outer=T,col=3)  # add text in the
# outer margin on side 1
mtext("plot margin 4",side=4,col=2,line=1)# text on side 4 illustr. line option
mtext("plot margin 4", side = 4,col=2,line=2)
mtext("outer margin 4",side=4,col=3,line=1,outer=T)# same, for outer margin
mtext("outer margin 4",side=4,col=3,line=2,outer=T)

# now let's look at the inner and outer margins when there are multiple plots
# on a page

par(mfrow=c(2,2),oma=c(4,4,4,4),mar=c(4,4,4,4))
box(which="figure",lty=2,col=3) # can't add a box until a plot has been created
plot(x1,y1,typ="l")              # make the first plot              
box(which="plot",lty=1,col=2)    # box around plot
box(which="figure",lty=2,col=3)  # NOTE where the box goes!
mtext("plot margin 1",side=1,line=2,col=2)  # add some text in the inner margin
plot(x2,y2,typ="l")              # make the second plot
box(which="plot",lty=1,col=2) 
box(which="figure",lty=2,col=3)
mtext("plot margin 1",side=1,line=2,col=2)  # add some text in the inner margin
# add text to the outer margin: NOTE where the text goes!
mtext("outer margin 2",side=2,line=2,col=3,outer=T)
par(mar=c(4,4,0,0))     # make our 3rd graph, but change the margins
plot(x1,y1,typ="l")
box(which="plot", col=2,lty=1)
# let's add the box around the outside now
box(which="figure",col=3,lty=2)
# let's do the last graph
par(mar=c(4,4,4,4))
plot(x2,y2,typ="l")
mtext("inner margin, line=0",line=0,col=2,side=1)
mtext("inner margin, line=2",line=2,col=2,side=1)
mtext("inner margin, line=4",line=4,col=2,side=1)
# add some text to the outer margins
mtext("outer margin 1",line=2,col=3,side=1,outer=T)
mtext("outer margin 3",line=2,col=3,side=3,outer=T)
mtext("outer margin 4",line=2,col=3,side=4,outer=T)


#Multiplots in one page
# MS698 - Statistical and Graphical Analysis in R                     Fall, 2010 

# Instructor:	Janos (John) M. Hoenig 
# Contact:	hoenig@vims.edu  
#           office: x7125; home: 757 564 9766; cell: 804 815 2912


############################################################
#
# How to arrange several plots on one page: layout( ), split.screen( ), and
# par(fig= )).  See also the file called "the wonders of scatterplots.r" for
# description of pairs() and other similar functions and for info on panel
# functions.
#
############################################################

ans <- read.table(paste(hndl,"Lesson5_anscombe_quartet.txt",sep=''),header=T)
ans
x1 <- ans$x1
y1 <- ans$y1
x2 <- ans$x2
y2 <- ans$y2
x3 <- ans$x3
y3 <- ans$y3
x4 <- ans$x4
y4 <- ans$y4

# To plot several graphs on the same pages there are several approaches that 
# are mutually incompatible.

# You can indicate in the par() function the mfrow or mfcol
par(mfrow=c(4,2))
plot(x1,y1)
plot(y1,x1)
plot(x2,y2)
plot(y2,x2)
plot(x3,y3)
plot(y3,x3)
plot(x4,y4)
plot(y4,x4)

#A more versatile approach is to use the layout function
matrix(c(2,0,1,3),2,2,byrow=T)  # shows we want to draw the first plot at the
# bottom left, the second at top left, the
# third at bottom right, and we want blank
# space at top right (indicated by 0)
layout(matrix(c(2,0,1,3),2,2,byrow=T))
plot(x1,y1)
plot(x2,y2)
plot(x3,y3)


# now let's try specifying relative heights
layout(matrix(c(1,2)), height=c(2,1))
matrix(c(1,2))  # says we want plot 1 above plot 2
# This gives a page with two graphs one on top of the other.
# These two graphs have different proportions: the height of the first is 
# 2/(2+1); height of the bottom graph is 1/(2+1)
plot(x1,y1)
plot(y1,x1)

# This makes for very awkward looking graphs because the width and height 
# proportions are not respected
layout(matrix(c(1,2)), height=c(2,1),respect=T)  # "respect" (retain) the
# original proportions
plot(x1,y1)
plot(y1,x1)

# You can also have some graphs occupying more than 1 column or more than 1 row
layout(rbind(c(1,2),
             c(1,3)), heights=c(1,1,1))  # says first graph will occupy entire
# left side (see below)
plot(x2,y2,las=1)                       # first graph - appears on the left side
plot(x3,y3,pch=3,las=1) # 2nd graph
plot(x4,y4)                             # 3rd graph


# Another way to put several graphs on one page is to use split.screen( ) to
# divide the plotting page.
# Each figure region can then be subdivided into more regions using the 
# split.screen( ) function again.
# The user can call any region in any order and return later on to previously 
# used regions to add a line, etc.

split.screen(c(1,2))  # one row, 2 columns         
screen(1)
ylimits = range(c(y1,y2))
xlimits = range(c(x1,x2))
plot(x2,y2,xlim=xlimits,ylim=ylimits,las=1)
par(new=T)
plot(x1,y1,pch=3,xlim=xlimits,ylim=ylimits,ylab="",xlab="",las=1)
screen(2) # go to screen 2
split.screen(c(2,1), screen = 2)   # we'll split screen 2 into 2 (then the
# previous line is not needed
screen(3)     # screen 3 is now the first screen in the split of screen 2
plot(x3,y3)
abline(h=8,lty=3)
screen(4)    # go to screen 4 (second part of screen 2)
plot(x4,y4)
abline(h=7,lty=3)

close.screen(all = TRUE)   # this ends the session creating the graphs.

# One more method for specifying plot locations & sizes: par(fig=c(x1,x2,y1,y2))
# where x1,y1 give the lower left corner of the plot and x2,y2 give the upper
# right corner. The units are specified as follows: the lower left corner of the
# the plot region is the point (0,0) and the top right corner is (1,1).

# let's put two graphs on a page, one in the lower left corner and one in the
# upper right.                                                          

# start with the graph is the lower left. We specificy the (x,y) values of the
# lower left and top right corners). You need to know that the bottom left
# corner of the page is (0,0) and the top right corner is (1,1). 
par(fig=c(0,.6,0,.6))
plot(x1,y1)
par(fig=c(.6,1,.6,1),new=T)  # NOTE: you need to specify new=T or first plot
# will be erased.
plot(x2,y2)

# Note that the bottom graph extends up to y = .6 and the top graph extends
# down to y = .6 but there is a big gap between the graphs. That's because the
# graphs have margins; we can reset the margins using par(mar= )  You need to
# know that that the margins are specified in the order: bottom, left, top,
# right.

par(mar=c(0,0,5,1))    # margins for first graph. (Bottom & left margins are 0)
par(fig=c(.6,1,.6,1))
plot(x2,y2)
mtext("top right graph")
par(mar=c(5,5,0,0))      # margins for second graph  (top & right margins are 0)
par(fig=c(0,.6,0,.6),new=T)
plot(x1,x2)
mtext("bottom left graph")
# add one more graph
par(mar=c(4,1,0,0),fig=c(.4,.58,.15,.35),new=T)
plot(x3,y3)





#-----#GGPLOT--------------------

#source
#http://r-statistics.co/Complete-Ggplot2-Tutorial-Part1-With-R-Code.html
#http://r-statistics.co/Complete-Ggplot2-Tutorial-Part2-Customizing-Theme-With-R-Code.html
# http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html

library(ggplot2)

#Basic map to understand ggplot syntax

#1. load some data
data("midwest", package = "ggplot2") 


#2.  Init Ggplot
ggplot(midwest, aes(x=area, y=poptotal))
# area and poptotal are columns in 'midwest'
head(midwest,2)

# what happened?
# A blank ggplot is drawn. Even though the x and y are specified,
#  there are no points or lines in it. This is because, ggplot doesn’t
#  assume that you meant a scatterplot or a line chart to be drawn.
#Also note that aes() function is used to specify the X and Y axes


#3. Let's make simple scaterplot
ggplot(midwest, aes(x=area, y=poptotal)) +
  geom_point()


#4. Let's add a smoothing line
g <- ggplot(midwest, aes(x=area, y=poptotal)) + 
  geom_point() + 
  geom_smooth(method="lm")  # set se=FALSE to turnoff confidence bands
plot(g)
#note how I saved the ggplot to an object ("g") and the plotted 'g'


#5. Adjust X and Y
g + xlim(c(0, 0.1)) + ylim(c(0, 1000000))
#note how I recall 'g' and built on top...


#6. Adjust X and Y by zooming in 
# (this does not delete points outside X and Y range)
g1 <- g + coord_cartesian(xlim=c(0,0.1), ylim=c(0, 1000000))  # zooms in
plot(g1)

#Since all points were considered, the line of best fit did not change
# compare to previous graph....


#7. Change title and axis lables
g1 + 
  labs(title="Area Vs Population", subtitle="From midwest dataset", 
       y="Population", x="Area", caption="Midwest Demographics")
# or
g1 + 
  ggtitle("Area Vs Population", subtitle="From midwest dataset") +
  xlab("Area") +
  ylab("Population")


#8. Change color and size of points
ggplot(midwest, aes(x=area, y=poptotal)) + 
  geom_point(col="steelblue", size=3) +   # Set static color and size for points
  geom_smooth(method="lm", col="firebrick") +  # change the color of line
  coord_cartesian(xlim=c(0, 0.1), ylim=c(0, 1000000)) + 
  labs(title="Area Vs Population", 
       subtitle="From midwest dataset", 
       y="Population", 
       x="Area", 
       caption="Midwest Demographics")
    

#9. Change color to reflect categories in another column
gg <- ggplot(midwest, aes(x=area, y=poptotal)) + 
  geom_point(aes(col=state), size=3) +  # Set color to vary based on state categories.
  geom_smooth(method="lm", col="firebrick", size=2) + 
  coord_cartesian(xlim=c(0, 0.1), ylim=c(0, 1000000)) + 
  labs(title="Area Vs Population", 
       subtitle="From midwest dataset", 
       y="Population", 
       x="Area", 
       caption="Midwest Demographics")
plot(gg)
#Now each point is colored based on the state it belongs because of aes(col=state).
# Not just color, but size, shape, stroke (thickness of boundary) 
#  and fill (fill color) can be used to discriminate groupings.

#remove legend if don't want it
gg + theme(legend.position="None")  # remove legend

#change color of palette
gg + scale_colour_brewer(palette = "Set1")  # change color palette

#you can check the palette options here
library(RColorBrewer)
head(brewer.pal.info, 10)


#9. Change axis text and ticks location
gg + scale_x_continuous(breaks=seq(0, 0.1, 0.01)) #change tick location
gg + scale_x_continuous(breaks=seq(0, 0.1, 0.01),
                        labels = letters[1:11])  #change tick location and name

#10. Reverse the X Axis Scale
gg + scale_x_reverse()


#11. Change theme 
gg + theme_bw() + labs(subtitle="BW Theme")
gg + theme_classic() + labs(subtitle="Classic Theme")
gg + theme_dark() + labs(subtitle="Dark Theme")


#12. Add plot components
gg <- ggplot(midwest, aes(x=area, y=poptotal)) + 
  geom_point(aes(col=state, size=popdensity)) + #changed points color and size
  geom_smooth(method="loess", se=F) +   #added smoothing spline
  xlim(c(0, 0.1)) +
  ylim(c(0, 500000)) + 
  labs(title="Area Vs Population", y="Population",
       x="Area", caption="Source: midwest")
plot(gg)


#13. Modify theme components
gg + theme(plot.title=element_text(size=20, 
                                   face="bold", 
                                   family="American Typewriter",
                                   color="tomato",
                                   hjust=0.5,
                                   lineheight=1.2),  # title
           plot.subtitle=element_text(size=15, 
                                      family="American Typewriter",
                                      face="bold",
                                      hjust=0.5),  # subtitle
           plot.caption=element_text(size=15),  # caption
           axis.title.x=element_text(vjust=10,  
                                     size=15),  # X axis title
           axis.title.y=element_text(size=15),  # Y axis title
           axis.text.x=element_text(size=10, 
                                    angle = 30,
                                    vjust=.5),  # X axis text
           axis.text.y=element_text(size=10))  # Y axis text


#14. Modify legend and add text
midwest_sub <- midwest[midwest$poptotal > 300000, ]
midwest_sub$large_county <- ifelse(midwest_sub$poptotal > 300000, midwest_sub$county, "")

gg + geom_text(aes(label=large_county), size=2, data=midwest_sub) +
  labs(subtitle="With ggplot2::geom_text") +
  guides(color=guide_legend("State"), size=guide_legend("Density"))  

#move text so we can actually see it and remove legends
library(ggrepel)
gg + geom_label_repel(aes(label=large_county), size=2, data=midwest_sub) +
     labs(subtitle="With ggrepel::geom_label_repel") +
     theme(legend.position = "None")


#15. Multiple plots in one page
data(mpg, package="ggplot2")  # load data

g <- ggplot(mpg, aes(x=displ, y=hwy)) + 
  geom_point() + 
  labs(title="hwy vs displ", caption = "Source: mpg") +
  geom_smooth(method="lm", se=FALSE) + 
  theme_bw()  # apply bw theme
plot(g)

  #same scale
g + facet_wrap( ~ class, nrow=3) + 
  labs(title="hwy vs displ", caption = "Source: mpg", 
       subtitle="Ggplot2 - Faceting - Multiple plots in one figure")  # Shared scales

# Facet wrap with free scales
g + facet_wrap( ~ class, scales = "free") +
  labs(title="hwy vs displ", caption = "Source: mpg",
       subtitle="Ggplot2 - Faceting - Multiple plots in one figure with free scales")  


#16. Add an image
library(grid)
library(magick)

  #import tiger image
tiger <- image_read_svg('http://jeroen.github.io/images/tiger.svg', width = 350)

  #convert image to raster
g_pic <- rasterGrob(tiger, interpolate=TRUE)

  #add image to graph
g+ annotation_custom(g_pic , xmin=5, xmax=7, ymin=30, ymax=45)
ggsave("C:/Matias/Cursos/2019_Mexico/Plots_Maps/tiger.png", width = 6, height = 6, dpi = "screen")

#-----Base mapping--------------------




#-----ggplot MAPPING--------------------
#source:
#  https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html
#  https://www.r-spatial.org/r/2018/10/25/ggplot2-sf-2.html

library("ggplot2")
theme_set(theme_bw()) #classic dark-on-light theme for ggplot2 (good for maps) check other themes in ?ggtheme

library("sf")

# The package rnaturalearth provides a map of countries of the entire world. 
library("rnaturalearth")
library("rnaturalearthdata")

# Use ne_countries to pull country data and choose the scale 
# (rnaturalearthhires is necessary for scale = "large"). 
# The function can return sp classes (default) or directly sf classes, 
# as defined in the argument returnclass:                   
world <- ne_countries(scale = "medium", returnclass = "sf")
class(world)

#First, create a base map of the world using ggplot2.
# This base map will then be extended with different map elements
ggplot(data = world) +
       geom_sf()
#note that layers are added one at a time in ggplot... type just ggplot(data = world)

#add title and change countries' color
ggplot(data = world) +
  geom_sf(color = "orange", fill = "pink") +
  xlab("Longitude") + ylab("Latitude") +
  ggtitle("World map", subtitle = paste0("(", length(unique(world$name)), " countries)"))


#or maybe use color according to population size of each country
ggplot(data = world) +
  geom_sf(aes(fill = pop_est)) +
  scale_fill_viridis_c(option = "plasma", trans = "sqrt")
#here it is using the pop_est to fill a gradient...
world$pop_est[1:5]


#change map projection
ggplot(data = world) +
  geom_sf() +
  coord_sf(crs = "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs ")
#the function 'coord_sf' allows to deal with the coordinate system, 
# which includes both projection and extent of the map.

#Zoom in into the Gulf of Mexico
ggplot(data = world) +
  geom_sf() +
  coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97), expand = T)
# The extent of the map can also be set in coord_sf, in practice allowing to “zoom” 
# in the area of interest, provided by limits on the x-axis (xlim), and on the y-axis (ylim)
       

#Add scale bar
library("ggspatial")
ggplot(data = world) +
  geom_sf() +
  annotation_scale(location = "bl", width_hint = 0.5) +
  annotation_north_arrow(location = "bl", which_north = "true", 
                         pad_x = unit(0.75, "in"), pad_y = unit(0.5, "in"),
                         style = north_arrow_fancy_orienteering) +
  coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97))


#Add text (e.g. country name)
# The world data set already contains country names 
# and the coordinates of the centroid of each country (among more information)

world_points<- st_centroid(world)   #function from package 'sf'
world_points <- cbind(world, st_coordinates(st_centroid(world$geometry)))

ggplot(data = world) +
  geom_sf() +
  geom_text(data= world_points,aes(x=X, y=Y, label=name),
            color = "darkblue", fontface = "bold", size = 4, check_overlap = FALSE) +
  annotate(geom = "text", x = -90, y = 26, label = "Gulf of Mexico", 
           fontface = "italic", color = "grey22", size = 4) +
  coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97), expand = FALSE)


#Final map
ggplot(data = world) +
  geom_sf(fill= 'antiquewhite') +
  geom_text(data= world_points,aes(x=X, y=Y, label=name),
            color = 'darkblue', fontface = 'bold', check_overlap = FALSE) +
  annotate(geom = 'text', x = -90, y = 26, label = 'Gulf of Mexico',
           fontface = 'italic', color = 'grey22', size = 6) +
  annotation_scale(location = 'bl', width_hint = 0.5) +
  annotation_north_arrow(location = 'bl', which_north = 'true', 
          pad_x = unit(0.75, 'in'), pad_y = unit(0.5, 'in'),
          style = north_arrow_fancy_orienteering) +
  coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97), expand = FALSE) +
  xlab('Longitude') + ylab('Latitude') + 
  ggtitle('Map of the Gulf of Mexico and the Caribbean Sea') +
  theme(panel.grid.major = element_line(color = gray(.5),
        linetype = 'dashed', size = 0.5), 
        panel.background = element_rect(fill = 'aliceblue'))


#Saving the map 
ggsave("C:/Matias/Cursos/2019_Mexico/Plots_Maps/map.pdf")
ggsave("C:/Matias/Cursos/2019_Mexico/Plots_Maps/map_web.png", width = 6, height = 6, dpi = "screen")
#ggsave saves that last map on display....


#Add some field sites (point data)

#create the site data
(sites <- data.frame(longitude = c(-80.144005, -80.109), 
                     latitude = c(26.479005, 26.83)))

#quickest way to add points to map
ggplot(data = world) +
  geom_sf() +
  geom_point(data = sites, aes(x = longitude, y = latitude), size = 4, 
             shape = 23, fill = "darkred") +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)

#more flexible way, use 'sf' to convert sites to a coordinate system 
#   (e.g. more useful if changing projections)
(sites <- st_as_sf(sites, coords = c("longitude", "latitude"), 
                   crs = 4326, agr = "constant"))
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = sites, size = 4, shape = 23, fill = "darkred") +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)


#Polygon data (e.g. States)
library("maps")   #only useful if plotting USA stuff...
              # used here for illustrative purposes...
states <- st_as_sf(map("state", plot = FALSE, fill = TRUE))
head(states)

#get the centroid for plotting each state name
states <- cbind(states, st_coordinates(st_centroid(states)))
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = states, fill = NA) + 
  geom_text(data = states, aes(X, Y, label = ID), size = 5) +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)

#move state name a bit
states$nudge_y <- -1
states$nudge_y[states$ID == "Florida"] <- 0.5
states$nudge_y[states$ID == "South Carolina"] <- -1.5
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = states, fill = NA) + 
  geom_label(data = states, aes(X, Y, label = ID), size = 5, fontface = "bold", 
             nudge_y = states$nudge_y) +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)


#highlight different counties (polygons...)
counties <- st_as_sf(map("county", plot = FALSE, fill = TRUE))
counties <- subset(counties, grepl("florida", counties$ID))
counties$area <- as.numeric(st_area(counties))

#add counties as a gray outline
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = counties, fill = NA, color = gray(.5)) +   
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)

#show counties by some property (e.g. area; in our case, some random variable)
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = counties, aes(fill = runif(length(counties$ID),1,10))) +
  scale_fill_viridis_c(trans = "sqrt", alpha = .4) +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)


#Show more specific data points
flcities <- data.frame(state = rep("Florida", 5), 
                       city = c("Miami","Tampa", "Orlando", "Jacksonville", "Sarasota"),
                       lat = c(25.7616798,27.950575, 28.5383355, 30.3321838, 27.3364347),
                       lng = c(-80.1917902,-82.4571776, -81.3792365, -81.655651, -82.5306527))

(flcities <- st_as_sf(flcities, coords = c("lng", "lat"), remove = FALSE, 
                      crs = 4326, agr = "constant"))
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = counties, fill = NA, color = gray(.5)) +
  geom_sf(data = flcities) +
  geom_text(data = flcities, aes(x = lng, y = lat, label = city), 
            size = 3.9, col = "black", fontface = "bold") +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)


#doesn't look that good, let's move the legend
library("ggrepel")
ggplot(data = world) +
  geom_sf() +
  geom_sf(data = counties, fill = NA, color = gray(.5)) +
  geom_sf(data = flcities) +
  geom_text_repel(data = flcities, aes(x = lng, y = lat, label = city), 
                  fontface = "bold", nudge_x = c(1, -1.5, 2, 2, -1),
                  nudge_y = c(0.25,-0.25, 0.5, 0.5, -0.5)) +
  coord_sf(xlim = c(-88, -78), ylim = c(24.5, 33), expand = FALSE)


#-----Another approach. tmap--------------------
#source:
#  https://geocompr.robinlovelace.net/adv-map.html

install.packages(c("tmap","spData"))
library(tmap)
library(spData)

#Just like ggplot2, tmap is based on the idea of a ‘grammar of graphics’
# This involves a separation between the input data and the aesthetics 
# (how data are visualised): each input dataset can be ‘mapped’ in a 
# range of different ways including location on the map (defined by 
# data’s geometry), color, and other visual variables.


# Add fill layer to nz shape
tm_shape(nz) +
  tm_fill() 

# Add border layer to nz shape
tm_shape(nz) +
  tm_borders() 

# Add fill and border layers to nz shape
nz=tm_shape(nz) +
  tm_fill() +
  tm_borders() 
nz
  
#many more useful features, including how to animate maps..
# ...check here:
#  https://geocompr.robinlovelace.net/adv-map.html

#-----mapview- interactive maps--------------------
#install.packages(c("mapview", "leaflet"))
library(mapview)
library(leaflet)
m=mapview(breweries)

m2=leaflet() %>% addProviderTiles("OpenStreetMap") %>% addExtent(breweries) 

#save as html
mapshot(m, url = paste0('C:/Matias/Cursos/2019_Mexico/Plots_Maps', "/map.html"))
mapshot(m2, url = paste0('C:/Matias/Cursos/2019_Mexico/Plots_Maps', "/map2.html"))


#can also use tmap
tmap_mode("view")
nz
